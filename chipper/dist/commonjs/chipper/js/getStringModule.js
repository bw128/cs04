"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.localizedStrings = exports["default"] = void 0;
var _PhetioObject = _interopRequireDefault(require("../../tandem/js/PhetioObject.js"));
var _Tandem = _interopRequireDefault(require("../../tandem/js/Tandem.js"));
var _CouldNotYetDeserializeError = _interopRequireDefault(require("../../tandem/js/CouldNotYetDeserializeError.js"));
var _IOType = _interopRequireDefault(require("../../tandem/js/types/IOType.js"));
var _ObjectLiteralIO = _interopRequireDefault(require("../../tandem/js/types/ObjectLiteralIO.js"));
var _LocalizedString = _interopRequireDefault(require("./LocalizedString.js"));
var _localeInfoModule = _interopRequireDefault(require("../../chipper/js/data/localeInfoModule.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); } // Copyright 2020-2024, University of Colorado Boulder
/**
 * Given a requirejsNamespace, we filter out strings from phet.chipper.strings that start with it, and construct an
 * object with locale fallbacks already pre-computed, so that the correct strings can be accessed via object literal
 * access, e.g. getStringModule( 'JOIST' ).ResetAllButton.name will give the desired string value for whatever locale
 * the sim is being run with.
 *
 * A string "key" is in the form of "NAMESPACE/key.from.strings.json"
 *
 * NOTE: This file likely belongs in joist/js/i18n/, but should stay here to make maintenance-release maintainability easier.
 *
 * @author Jonathan Olson <jonathan.olson>
 */
// constants
var FALLBACK_LOCALE = 'en';

// Holds all of our localizedStrings, so that we can save our phet-io string change state
var localizedStrings = exports.localizedStrings = [];

// For developer internal use, particularly for memory leak detection
// e.g. _.max( phet.chipper.localizedStrings.map( ls => ls.property.tinyProperty.listeners.size ) ) to see if there is
// likely a leak
window.phet.chipper.localizedStrings = localizedStrings;

// For developer internal use, similar to the stringTest query parameter
window.phet.chipper.setAllStrings = function (str) {
  localizedStrings.forEach(function (localizedString) {
    localizedString.property.value = str;
  });
};
var stringKeyToTandemName = function stringKeyToTandemName(key) {
  return key.replace(/(?:[-_\s]\w)/g, function (word) {
    return word[1].toUpperCase();
  });
};
var StringStateIOType = new _IOType["default"]('StringStateIO', {
  valueType: _PhetioObject["default"],
  toStateObject: function toStateObject() {
    var data = {};
    localizedStrings.forEach(function (localizedString) {
      var state = localizedString.getStateDelta();

      // Only create an entry if there is anything (we can save bytes by not including the tandem here)
      if (Object.keys(state).length > 0) {
        data[localizedString.property.tandem.phetioID] = state;
      }
    });
    return {
      data: data // Data nested for a valid schema
    };
  },
  stateSchema: {
    data: _ObjectLiteralIO["default"]
  },
  applyState: function applyState(ignored, state) {
    // Every string in state has to be in localizedStrings to continue
    Object.keys(state.data).forEach(function (phetioID) {
      var match = localizedStrings.find(function (localizedString) {
        return localizedString.property.tandem.phetioID === phetioID;
      });

      // When PhetioDynamicElementContainer elements such as PhetioGroup members add localizedStrings, we wait until
      // all of the members have been created (populating localizedStrings) before trying to set any of the strings.
      if (!match) {
        throw new _CouldNotYetDeserializeError["default"]();
      }
    });

    // We need to iterate through every string in this runtime, since it might need to revert back to "initial" state.
    localizedStrings.forEach(function (localizedString) {
      localizedString.setStateDelta(state.data[localizedString.property.tandem.phetioID] || {});
    });
  }
});
_PhetioObject["default"].create({
  phetioType: StringStateIOType,
  tandem: _Tandem["default"].GENERAL_MODEL.createTandem('stringsState'),
  phetioDocumentation: 'Strings that have changed from their initial values. Each string value is specific to the locale it changed in.',
  phetioState: true
});
/**
 * @param requirejsNamespace - E.g. 'JOIST', to pull string keys out from that namespace
 * @returns Nested object to be accessed like JoistStrings.ResetAllButton.name
 */
var getStringModule = function getStringModule(requirejsNamespace) {
  // Our string information is pulled globally, e.g. phet.chipper.strings[ locale ][ stringKey ] = stringValue;
  // Our locale information is from phet.chipper.locale

  assert && assert(typeof phet.chipper.locale === 'string', 'phet.chipper.locale should have been loaded by now');
  assert && assert(Object.keys(_localeInfoModule["default"]).includes(phet.chipper.locale), 'phet.chipper.locale should have been loaded by now');
  assert && assert(phet.chipper.strings, 'phet.chipper.strings should have been loaded by now');

  // Construct locales in increasing specificity, e.g. [ 'en', 'zh', 'zh_CN' ], so we get fallbacks in order
  // const locales = [ FALLBACK_LOCALE ];
  var stringKeyPrefix = "".concat(requirejsNamespace, "/");

  // We may have other older (unused) keys in babel, and we are only doing the search that matters with the English
  // string keys.
  var allStringKeysInRepo = Object.keys(phet.chipper.strings[FALLBACK_LOCALE]).filter(function (stringKey) {
    return stringKey.startsWith(stringKeyPrefix);
  });

  // TODO: https://github.com/phetsims/phet-io/issues/1877 What if this list doesn't exist?  Should that be an error?
  // Or an error if running an api-stable phet-io sim?
  // TODO: https://github.com/phetsims/phet-io/issues/1877 What will happen if this is stale? How will a developer know
  // to update it? Should it run in daily-grunt-work?
  if (phet.chipper.usedStringsEN) {
    allStringKeysInRepo = allStringKeysInRepo.filter(function (stringKey) {
      return phet.chipper.usedStringsEN.hasOwnProperty(stringKey);
    });
  }

  // localizedStringMap[ stringKey ]
  var localizedStringMap = {};
  var stringModule = {};
  allStringKeysInRepo.forEach(function (stringKey) {
    // strip off the requirejsNamespace, e.g. 'JOIST/ResetAllButton.name' => 'ResetAllButton.name'
    var stringKeyWithoutPrefix = stringKey.slice(stringKeyPrefix.length);
    var keyParts = stringKeyWithoutPrefix.split('.');
    var lastKeyPart = keyParts[keyParts.length - 1];
    var allButLastKeyPart = keyParts.slice(0, keyParts.length - 1);

    // During traversal into the string object, this will hold the object where the next level needs to be defined,
    // whether that's another child object, or the string value itself.
    var reference = stringModule;

    // We'll traverse down through the parts of a string key (separated by '.'), creating a new level in the
    // string object for each one. This is done for all BUT the last part, since we'll want to assign the result
    // of that to a raw string value (rather than an object).
    var partialKey = stringKeyPrefix;
    allButLastKeyPart.forEach(function (keyPart, i) {
      // When concatenating each level into the final string key, we don't want to put a '.' directly after the
      // slash, because `JOIST/.ResetAllButton.name` would be invalid.
      // See https://github.com/phetsims/chipper/issues/922
      partialKey += "".concat(i > 0 ? '.' : '').concat(keyPart);

      // Don't allow e.g. JOIST/a and JOIST/a.b, since localeObject.a would need to be a string AND an object at the
      // same time.
      assert && assert(typeof reference[keyPart] !== 'string', 'It is not allowed to have two different string keys where one is extended by adding a period (.) at the end ' + "of the other. The string key ".concat(partialKey, " is extended by ").concat(stringKey, " in this case, and should be changed."));

      // Create the next nested level, and move into it
      if (!reference[keyPart]) {
        reference[keyPart] = {};
      }
      reference = reference[keyPart]; // since we are on all but the last key part, it cannot be stringlike
    });
    assert && assert(_typeof(reference[lastKeyPart]) !== 'object', 'It is not allowed to have two different string keys where one is extended by adding a period (.) at the end ' + "of the other. The string key ".concat(stringKey, " is extended by another key, something containing ").concat(reference[lastKeyPart] && Object.keys(reference[lastKeyPart]), "."));
    assert && assert(!reference[lastKeyPart], "We should not have defined this place in the object (".concat(stringKey, "), otherwise it means a duplicated string key OR extended string key"));

    // In case our assertions are not enabled, we'll need to proceed without failing out (so we allow for the
    // extended string keys in our actual code, even though assertions should prevent that).
    if (typeof reference !== 'string') {
      var tandem = _Tandem["default"].STRINGS.createTandem(_.camelCase(requirejsNamespace));
      for (var i = 0; i < keyParts.length; i++) {
        var tandemName = stringKeyToTandemName(keyParts[i]);

        // If it is the tail of the string key, then make the tandem be a "*StringProperty"
        if (i === keyParts.length - 1) {
          var currentTandemName = tandemName;
          var j = 0;
          var tandemNameTaken = true;

          // Handle the case where two unique string keys map to the same camel case value, i.e. "Solid" and "solid".
          // Here we will be solidStringProperty and solid2StringProperty
          while (tandemNameTaken) {
            j++;
            currentTandemName = "".concat(tandemName).concat(j === 1 ? '' : j, "StringProperty");
            tandemNameTaken = tandem.hasChild(currentTandemName);
          }
          tandemName = currentTandemName;
        }
        tandem = tandem.createTandem(tandemName);
      }

      // strings nested under the a11y section are not currently PhET-iO instrumented, see https://github.com/phetsims/chipper/issues/1352
      if (tandem.phetioID.includes('.a11y.')) {
        tandem = _Tandem["default"].OPT_OUT;
      }
      var localizedString = new _LocalizedString["default"](stringKey, phet.chipper.mapString(phet.chipper.strings[FALLBACK_LOCALE][stringKey]), tandem, phet.chipper.stringMetadata[stringKey]);
      localizedStringMap[stringKey] = localizedString;

      // Push up the translated values
      Object.keys(phet.chipper.strings).forEach(function (locale) {
        var string = phet.chipper.strings[locale][stringKey];
        // Ignore zero-length strings, see https://github.com/phetsims/chipper/issues/1343
        if (typeof string === 'string' && string !== '') {
          localizedString.setInitialValue(locale, phet.chipper.mapString(string));
        }
      });

      // Put our Property in the stringModule
      reference["".concat(lastKeyPart, "StringProperty")] = localizedString.property;

      // Change our stringModule based on the Property value
      localizedString.property.link(function (string) {
        reference[lastKeyPart] = string;
      });
    }
  });
  return stringModule;
};
var _default = exports["default"] = getStringModule;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfUGhldGlvT2JqZWN0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfVGFuZGVtIiwiX0NvdWxkTm90WWV0RGVzZXJpYWxpemVFcnJvciIsIl9JT1R5cGUiLCJfT2JqZWN0TGl0ZXJhbElPIiwiX0xvY2FsaXplZFN0cmluZyIsIl9sb2NhbGVJbmZvTW9kdWxlIiwib2JqIiwiX19lc01vZHVsZSIsIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIkZBTExCQUNLX0xPQ0FMRSIsImxvY2FsaXplZFN0cmluZ3MiLCJleHBvcnRzIiwid2luZG93IiwicGhldCIsImNoaXBwZXIiLCJzZXRBbGxTdHJpbmdzIiwic3RyIiwiZm9yRWFjaCIsImxvY2FsaXplZFN0cmluZyIsInByb3BlcnR5IiwidmFsdWUiLCJzdHJpbmdLZXlUb1RhbmRlbU5hbWUiLCJrZXkiLCJyZXBsYWNlIiwid29yZCIsInRvVXBwZXJDYXNlIiwiU3RyaW5nU3RhdGVJT1R5cGUiLCJJT1R5cGUiLCJ2YWx1ZVR5cGUiLCJQaGV0aW9PYmplY3QiLCJ0b1N0YXRlT2JqZWN0IiwiZGF0YSIsInN0YXRlIiwiZ2V0U3RhdGVEZWx0YSIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJ0YW5kZW0iLCJwaGV0aW9JRCIsInN0YXRlU2NoZW1hIiwiT2JqZWN0TGl0ZXJhbElPIiwiYXBwbHlTdGF0ZSIsImlnbm9yZWQiLCJtYXRjaCIsImZpbmQiLCJDb3VsZE5vdFlldERlc2VyaWFsaXplRXJyb3IiLCJzZXRTdGF0ZURlbHRhIiwiY3JlYXRlIiwicGhldGlvVHlwZSIsIlRhbmRlbSIsIkdFTkVSQUxfTU9ERUwiLCJjcmVhdGVUYW5kZW0iLCJwaGV0aW9Eb2N1bWVudGF0aW9uIiwicGhldGlvU3RhdGUiLCJnZXRTdHJpbmdNb2R1bGUiLCJyZXF1aXJlanNOYW1lc3BhY2UiLCJhc3NlcnQiLCJsb2NhbGUiLCJsb2NhbGVJbmZvTW9kdWxlIiwiaW5jbHVkZXMiLCJzdHJpbmdzIiwic3RyaW5nS2V5UHJlZml4IiwiY29uY2F0IiwiYWxsU3RyaW5nS2V5c0luUmVwbyIsImZpbHRlciIsInN0cmluZ0tleSIsInN0YXJ0c1dpdGgiLCJ1c2VkU3RyaW5nc0VOIiwiaGFzT3duUHJvcGVydHkiLCJsb2NhbGl6ZWRTdHJpbmdNYXAiLCJzdHJpbmdNb2R1bGUiLCJzdHJpbmdLZXlXaXRob3V0UHJlZml4Iiwic2xpY2UiLCJrZXlQYXJ0cyIsInNwbGl0IiwibGFzdEtleVBhcnQiLCJhbGxCdXRMYXN0S2V5UGFydCIsInJlZmVyZW5jZSIsInBhcnRpYWxLZXkiLCJrZXlQYXJ0IiwiaSIsIlNUUklOR1MiLCJfIiwiY2FtZWxDYXNlIiwidGFuZGVtTmFtZSIsImN1cnJlbnRUYW5kZW1OYW1lIiwiaiIsInRhbmRlbU5hbWVUYWtlbiIsImhhc0NoaWxkIiwiT1BUX09VVCIsIkxvY2FsaXplZFN0cmluZyIsIm1hcFN0cmluZyIsInN0cmluZ01ldGFkYXRhIiwic3RyaW5nIiwic2V0SW5pdGlhbFZhbHVlIiwibGluayIsIl9kZWZhdWx0Il0sInNvdXJjZXMiOlsiZ2V0U3RyaW5nTW9kdWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIwLTIwMjQsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGEgcmVxdWlyZWpzTmFtZXNwYWNlLCB3ZSBmaWx0ZXIgb3V0IHN0cmluZ3MgZnJvbSBwaGV0LmNoaXBwZXIuc3RyaW5ncyB0aGF0IHN0YXJ0IHdpdGggaXQsIGFuZCBjb25zdHJ1Y3QgYW5cclxuICogb2JqZWN0IHdpdGggbG9jYWxlIGZhbGxiYWNrcyBhbHJlYWR5IHByZS1jb21wdXRlZCwgc28gdGhhdCB0aGUgY29ycmVjdCBzdHJpbmdzIGNhbiBiZSBhY2Nlc3NlZCB2aWEgb2JqZWN0IGxpdGVyYWxcclxuICogYWNjZXNzLCBlLmcuIGdldFN0cmluZ01vZHVsZSggJ0pPSVNUJyApLlJlc2V0QWxsQnV0dG9uLm5hbWUgd2lsbCBnaXZlIHRoZSBkZXNpcmVkIHN0cmluZyB2YWx1ZSBmb3Igd2hhdGV2ZXIgbG9jYWxlXHJcbiAqIHRoZSBzaW0gaXMgYmVpbmcgcnVuIHdpdGguXHJcbiAqXHJcbiAqIEEgc3RyaW5nIFwia2V5XCIgaXMgaW4gdGhlIGZvcm0gb2YgXCJOQU1FU1BBQ0Uva2V5LmZyb20uc3RyaW5ncy5qc29uXCJcclxuICpcclxuICogTk9URTogVGhpcyBmaWxlIGxpa2VseSBiZWxvbmdzIGluIGpvaXN0L2pzL2kxOG4vLCBidXQgc2hvdWxkIHN0YXkgaGVyZSB0byBtYWtlIG1haW50ZW5hbmNlLXJlbGVhc2UgbWFpbnRhaW5hYmlsaXR5IGVhc2llci5cclxuICpcclxuICogQGF1dGhvciBKb25hdGhhbiBPbHNvbiA8am9uYXRoYW4ub2xzb24+XHJcbiAqL1xyXG5cclxuaW1wb3J0IFBoZXRpb09iamVjdCBmcm9tICcuLi8uLi90YW5kZW0vanMvUGhldGlvT2JqZWN0LmpzJztcclxuaW1wb3J0IFRhbmRlbSBmcm9tICcuLi8uLi90YW5kZW0vanMvVGFuZGVtLmpzJztcclxuaW1wb3J0IENvdWxkTm90WWV0RGVzZXJpYWxpemVFcnJvciBmcm9tICcuLi8uLi90YW5kZW0vanMvQ291bGROb3RZZXREZXNlcmlhbGl6ZUVycm9yLmpzJztcclxuaW1wb3J0IElPVHlwZSBmcm9tICcuLi8uLi90YW5kZW0vanMvdHlwZXMvSU9UeXBlLmpzJztcclxuaW1wb3J0IE9iamVjdExpdGVyYWxJTyBmcm9tICcuLi8uLi90YW5kZW0vanMvdHlwZXMvT2JqZWN0TGl0ZXJhbElPLmpzJztcclxuaW1wb3J0IExvY2FsaXplZFN0cmluZywgeyBMb2NhbGl6ZWRTdHJpbmdTdGF0ZURlbHRhLCBTdHJpbmdzU3RhdGVTdGF0ZU9iamVjdCB9IGZyb20gJy4vTG9jYWxpemVkU3RyaW5nLmpzJztcclxuaW1wb3J0IFRSZWFkT25seVByb3BlcnR5IGZyb20gJy4uLy4uL2F4b24vanMvVFJlYWRPbmx5UHJvcGVydHkuanMnO1xyXG5pbXBvcnQgeyBMb2NhbGUgfSBmcm9tICcuLi8uLi9qb2lzdC9qcy9pMThuL2xvY2FsZVByb3BlcnR5LmpzJztcclxuaW1wb3J0IGxvY2FsZUluZm9Nb2R1bGUgZnJvbSAnLi4vLi4vY2hpcHBlci9qcy9kYXRhL2xvY2FsZUluZm9Nb2R1bGUuanMnO1xyXG5pbXBvcnQgeyBQaGV0aW9JRCB9IGZyb20gJy4uLy4uL3RhbmRlbS9qcy9UYW5kZW1Db25zdGFudHMuanMnO1xyXG5cclxuLy8gY29uc3RhbnRzXHJcbmNvbnN0IEZBTExCQUNLX0xPQ0FMRSA9ICdlbic7XHJcblxyXG4vLyBIb2xkcyBhbGwgb2Ygb3VyIGxvY2FsaXplZFN0cmluZ3MsIHNvIHRoYXQgd2UgY2FuIHNhdmUgb3VyIHBoZXQtaW8gc3RyaW5nIGNoYW5nZSBzdGF0ZVxyXG5leHBvcnQgY29uc3QgbG9jYWxpemVkU3RyaW5nczogTG9jYWxpemVkU3RyaW5nW10gPSBbXTtcclxuXHJcbi8vIEZvciBkZXZlbG9wZXIgaW50ZXJuYWwgdXNlLCBwYXJ0aWN1bGFybHkgZm9yIG1lbW9yeSBsZWFrIGRldGVjdGlvblxyXG4vLyBlLmcuIF8ubWF4KCBwaGV0LmNoaXBwZXIubG9jYWxpemVkU3RyaW5ncy5tYXAoIGxzID0+IGxzLnByb3BlcnR5LnRpbnlQcm9wZXJ0eS5saXN0ZW5lcnMuc2l6ZSApICkgdG8gc2VlIGlmIHRoZXJlIGlzXHJcbi8vIGxpa2VseSBhIGxlYWtcclxud2luZG93LnBoZXQuY2hpcHBlci5sb2NhbGl6ZWRTdHJpbmdzID0gbG9jYWxpemVkU3RyaW5ncztcclxuXHJcbi8vIEZvciBkZXZlbG9wZXIgaW50ZXJuYWwgdXNlLCBzaW1pbGFyIHRvIHRoZSBzdHJpbmdUZXN0IHF1ZXJ5IHBhcmFtZXRlclxyXG53aW5kb3cucGhldC5jaGlwcGVyLnNldEFsbFN0cmluZ3MgPSAoIHN0cjogc3RyaW5nICkgPT4ge1xyXG4gIGxvY2FsaXplZFN0cmluZ3MuZm9yRWFjaCggbG9jYWxpemVkU3RyaW5nID0+IHtcclxuICAgIGxvY2FsaXplZFN0cmluZy5wcm9wZXJ0eS52YWx1ZSA9IHN0cjtcclxuICB9ICk7XHJcbn07XHJcblxyXG5jb25zdCBzdHJpbmdLZXlUb1RhbmRlbU5hbWUgPSAoIGtleTogc3RyaW5nICkgPT4ge1xyXG4gIHJldHVybiBrZXkucmVwbGFjZSggLyg/OlstX1xcc11cXHcpL2csIHdvcmQgPT4gd29yZFsgMSBdLnRvVXBwZXJDYXNlKCkgKTtcclxufTtcclxuXHJcbmNvbnN0IFN0cmluZ1N0YXRlSU9UeXBlID0gbmV3IElPVHlwZTxQaGV0aW9PYmplY3QsIFN0cmluZ3NTdGF0ZVN0YXRlT2JqZWN0PiggJ1N0cmluZ1N0YXRlSU8nLCB7XHJcbiAgdmFsdWVUeXBlOiBQaGV0aW9PYmplY3QsXHJcbiAgdG9TdGF0ZU9iamVjdDogKCk6IFN0cmluZ3NTdGF0ZVN0YXRlT2JqZWN0ID0+IHtcclxuICAgIGNvbnN0IGRhdGE6IFJlY29yZDxQaGV0aW9JRCwgTG9jYWxpemVkU3RyaW5nU3RhdGVEZWx0YT4gPSB7fTtcclxuXHJcbiAgICBsb2NhbGl6ZWRTdHJpbmdzLmZvckVhY2goIGxvY2FsaXplZFN0cmluZyA9PiB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gbG9jYWxpemVkU3RyaW5nLmdldFN0YXRlRGVsdGEoKTtcclxuXHJcbiAgICAgIC8vIE9ubHkgY3JlYXRlIGFuIGVudHJ5IGlmIHRoZXJlIGlzIGFueXRoaW5nICh3ZSBjYW4gc2F2ZSBieXRlcyBieSBub3QgaW5jbHVkaW5nIHRoZSB0YW5kZW0gaGVyZSlcclxuICAgICAgaWYgKCBPYmplY3Qua2V5cyggc3RhdGUgKS5sZW5ndGggPiAwICkge1xyXG4gICAgICAgIGRhdGFbIGxvY2FsaXplZFN0cmluZy5wcm9wZXJ0eS50YW5kZW0ucGhldGlvSUQgXSA9IHN0YXRlO1xyXG4gICAgICB9XHJcbiAgICB9ICk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBkYXRhOiBkYXRhIC8vIERhdGEgbmVzdGVkIGZvciBhIHZhbGlkIHNjaGVtYVxyXG4gICAgfTtcclxuICB9LFxyXG4gIHN0YXRlU2NoZW1hOiB7XHJcbiAgICBkYXRhOiBPYmplY3RMaXRlcmFsSU9cclxuICB9LFxyXG4gIGFwcGx5U3RhdGU6ICggaWdub3JlZCwgc3RhdGUgKSA9PiB7XHJcblxyXG4gICAgLy8gRXZlcnkgc3RyaW5nIGluIHN0YXRlIGhhcyB0byBiZSBpbiBsb2NhbGl6ZWRTdHJpbmdzIHRvIGNvbnRpbnVlXHJcbiAgICBPYmplY3Qua2V5cyggc3RhdGUuZGF0YSApLmZvckVhY2goIHBoZXRpb0lEID0+IHtcclxuICAgICAgY29uc3QgbWF0Y2ggPSBsb2NhbGl6ZWRTdHJpbmdzLmZpbmQoIGxvY2FsaXplZFN0cmluZyA9PiBsb2NhbGl6ZWRTdHJpbmcucHJvcGVydHkudGFuZGVtLnBoZXRpb0lEID09PSBwaGV0aW9JRCApO1xyXG5cclxuICAgICAgLy8gV2hlbiBQaGV0aW9EeW5hbWljRWxlbWVudENvbnRhaW5lciBlbGVtZW50cyBzdWNoIGFzIFBoZXRpb0dyb3VwIG1lbWJlcnMgYWRkIGxvY2FsaXplZFN0cmluZ3MsIHdlIHdhaXQgdW50aWxcclxuICAgICAgLy8gYWxsIG9mIHRoZSBtZW1iZXJzIGhhdmUgYmVlbiBjcmVhdGVkIChwb3B1bGF0aW5nIGxvY2FsaXplZFN0cmluZ3MpIGJlZm9yZSB0cnlpbmcgdG8gc2V0IGFueSBvZiB0aGUgc3RyaW5ncy5cclxuICAgICAgaWYgKCAhbWF0Y2ggKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IENvdWxkTm90WWV0RGVzZXJpYWxpemVFcnJvcigpO1xyXG4gICAgICB9XHJcbiAgICB9ICk7XHJcblxyXG4gICAgLy8gV2UgbmVlZCB0byBpdGVyYXRlIHRocm91Z2ggZXZlcnkgc3RyaW5nIGluIHRoaXMgcnVudGltZSwgc2luY2UgaXQgbWlnaHQgbmVlZCB0byByZXZlcnQgYmFjayB0byBcImluaXRpYWxcIiBzdGF0ZS5cclxuICAgIGxvY2FsaXplZFN0cmluZ3MuZm9yRWFjaCggbG9jYWxpemVkU3RyaW5nID0+IHtcclxuICAgICAgbG9jYWxpemVkU3RyaW5nLnNldFN0YXRlRGVsdGEoIHN0YXRlLmRhdGFbIGxvY2FsaXplZFN0cmluZy5wcm9wZXJ0eS50YW5kZW0ucGhldGlvSUQgXSB8fCB7fSApO1xyXG4gICAgfSApO1xyXG4gIH1cclxufSApO1xyXG5cclxuUGhldGlvT2JqZWN0LmNyZWF0ZSgge1xyXG4gIHBoZXRpb1R5cGU6IFN0cmluZ1N0YXRlSU9UeXBlLFxyXG4gIHRhbmRlbTogVGFuZGVtLkdFTkVSQUxfTU9ERUwuY3JlYXRlVGFuZGVtKCAnc3RyaW5nc1N0YXRlJyApLFxyXG4gIHBoZXRpb0RvY3VtZW50YXRpb246ICdTdHJpbmdzIHRoYXQgaGF2ZSBjaGFuZ2VkIGZyb20gdGhlaXIgaW5pdGlhbCB2YWx1ZXMuIEVhY2ggc3RyaW5nIHZhbHVlIGlzIHNwZWNpZmljIHRvIHRoZSBsb2NhbGUgaXQgY2hhbmdlZCBpbi4nLFxyXG4gIHBoZXRpb1N0YXRlOiB0cnVlXHJcbn0gKTtcclxuXHJcbnR5cGUgVFN0cmluZ01vZHVsZSA9IHtcclxuICBbIGtleTogc3RyaW5nIF06IFRTdHJpbmdNb2R1bGUgfCBzdHJpbmcgfCBUUmVhZE9ubHlQcm9wZXJ0eTxzdHJpbmc+O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSByZXF1aXJlanNOYW1lc3BhY2UgLSBFLmcuICdKT0lTVCcsIHRvIHB1bGwgc3RyaW5nIGtleXMgb3V0IGZyb20gdGhhdCBuYW1lc3BhY2VcclxuICogQHJldHVybnMgTmVzdGVkIG9iamVjdCB0byBiZSBhY2Nlc3NlZCBsaWtlIEpvaXN0U3RyaW5ncy5SZXNldEFsbEJ1dHRvbi5uYW1lXHJcbiAqL1xyXG5jb25zdCBnZXRTdHJpbmdNb2R1bGUgPSAoIHJlcXVpcmVqc05hbWVzcGFjZTogc3RyaW5nICk6IG9iamVjdCA9PiB7XHJcbiAgLy8gT3VyIHN0cmluZyBpbmZvcm1hdGlvbiBpcyBwdWxsZWQgZ2xvYmFsbHksIGUuZy4gcGhldC5jaGlwcGVyLnN0cmluZ3NbIGxvY2FsZSBdWyBzdHJpbmdLZXkgXSA9IHN0cmluZ1ZhbHVlO1xyXG4gIC8vIE91ciBsb2NhbGUgaW5mb3JtYXRpb24gaXMgZnJvbSBwaGV0LmNoaXBwZXIubG9jYWxlXHJcblxyXG4gIGFzc2VydCAmJiBhc3NlcnQoIHR5cGVvZiBwaGV0LmNoaXBwZXIubG9jYWxlID09PSAnc3RyaW5nJywgJ3BoZXQuY2hpcHBlci5sb2NhbGUgc2hvdWxkIGhhdmUgYmVlbiBsb2FkZWQgYnkgbm93JyApO1xyXG4gIGFzc2VydCAmJiBhc3NlcnQoIE9iamVjdC5rZXlzKCBsb2NhbGVJbmZvTW9kdWxlICkuaW5jbHVkZXMoIHBoZXQuY2hpcHBlci5sb2NhbGUgKSwgJ3BoZXQuY2hpcHBlci5sb2NhbGUgc2hvdWxkIGhhdmUgYmVlbiBsb2FkZWQgYnkgbm93JyApO1xyXG4gIGFzc2VydCAmJiBhc3NlcnQoIHBoZXQuY2hpcHBlci5zdHJpbmdzLCAncGhldC5jaGlwcGVyLnN0cmluZ3Mgc2hvdWxkIGhhdmUgYmVlbiBsb2FkZWQgYnkgbm93JyApO1xyXG5cclxuICAvLyBDb25zdHJ1Y3QgbG9jYWxlcyBpbiBpbmNyZWFzaW5nIHNwZWNpZmljaXR5LCBlLmcuIFsgJ2VuJywgJ3poJywgJ3poX0NOJyBdLCBzbyB3ZSBnZXQgZmFsbGJhY2tzIGluIG9yZGVyXHJcbiAgLy8gY29uc3QgbG9jYWxlcyA9IFsgRkFMTEJBQ0tfTE9DQUxFIF07XHJcbiAgY29uc3Qgc3RyaW5nS2V5UHJlZml4ID0gYCR7cmVxdWlyZWpzTmFtZXNwYWNlfS9gO1xyXG5cclxuICAvLyBXZSBtYXkgaGF2ZSBvdGhlciBvbGRlciAodW51c2VkKSBrZXlzIGluIGJhYmVsLCBhbmQgd2UgYXJlIG9ubHkgZG9pbmcgdGhlIHNlYXJjaCB0aGF0IG1hdHRlcnMgd2l0aCB0aGUgRW5nbGlzaFxyXG4gIC8vIHN0cmluZyBrZXlzLlxyXG4gIGxldCBhbGxTdHJpbmdLZXlzSW5SZXBvID0gT2JqZWN0LmtleXMoIHBoZXQuY2hpcHBlci5zdHJpbmdzWyBGQUxMQkFDS19MT0NBTEUgXSApLmZpbHRlciggc3RyaW5nS2V5ID0+IHN0cmluZ0tleS5zdGFydHNXaXRoKCBzdHJpbmdLZXlQcmVmaXggKSApO1xyXG5cclxuICAvLyBUT0RPOiBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvcGhldC1pby9pc3N1ZXMvMTg3NyBXaGF0IGlmIHRoaXMgbGlzdCBkb2Vzbid0IGV4aXN0PyAgU2hvdWxkIHRoYXQgYmUgYW4gZXJyb3I/XHJcbiAgLy8gT3IgYW4gZXJyb3IgaWYgcnVubmluZyBhbiBhcGktc3RhYmxlIHBoZXQtaW8gc2ltP1xyXG4gIC8vIFRPRE86IGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9waGV0LWlvL2lzc3Vlcy8xODc3IFdoYXQgd2lsbCBoYXBwZW4gaWYgdGhpcyBpcyBzdGFsZT8gSG93IHdpbGwgYSBkZXZlbG9wZXIga25vd1xyXG4gIC8vIHRvIHVwZGF0ZSBpdD8gU2hvdWxkIGl0IHJ1biBpbiBkYWlseS1ncnVudC13b3JrP1xyXG4gIGlmICggcGhldC5jaGlwcGVyLnVzZWRTdHJpbmdzRU4gKSB7XHJcbiAgICBhbGxTdHJpbmdLZXlzSW5SZXBvID0gYWxsU3RyaW5nS2V5c0luUmVwby5maWx0ZXIoIHN0cmluZ0tleSA9PiBwaGV0LmNoaXBwZXIudXNlZFN0cmluZ3NFTi5oYXNPd25Qcm9wZXJ0eSggc3RyaW5nS2V5ICkgKTtcclxuICB9XHJcblxyXG4gIC8vIGxvY2FsaXplZFN0cmluZ01hcFsgc3RyaW5nS2V5IF1cclxuICBjb25zdCBsb2NhbGl6ZWRTdHJpbmdNYXA6IFJlY29yZDxzdHJpbmcsIExvY2FsaXplZFN0cmluZz4gPSB7fTtcclxuXHJcbiAgY29uc3Qgc3RyaW5nTW9kdWxlOiBUU3RyaW5nTW9kdWxlID0ge307XHJcblxyXG4gIGFsbFN0cmluZ0tleXNJblJlcG8uZm9yRWFjaCggc3RyaW5nS2V5ID0+IHtcclxuICAgIC8vIHN0cmlwIG9mZiB0aGUgcmVxdWlyZWpzTmFtZXNwYWNlLCBlLmcuICdKT0lTVC9SZXNldEFsbEJ1dHRvbi5uYW1lJyA9PiAnUmVzZXRBbGxCdXR0b24ubmFtZSdcclxuICAgIGNvbnN0IHN0cmluZ0tleVdpdGhvdXRQcmVmaXggPSBzdHJpbmdLZXkuc2xpY2UoIHN0cmluZ0tleVByZWZpeC5sZW5ndGggKTtcclxuXHJcbiAgICBjb25zdCBrZXlQYXJ0cyA9IHN0cmluZ0tleVdpdGhvdXRQcmVmaXguc3BsaXQoICcuJyApO1xyXG4gICAgY29uc3QgbGFzdEtleVBhcnQgPSBrZXlQYXJ0c1sga2V5UGFydHMubGVuZ3RoIC0gMSBdO1xyXG4gICAgY29uc3QgYWxsQnV0TGFzdEtleVBhcnQgPSBrZXlQYXJ0cy5zbGljZSggMCwga2V5UGFydHMubGVuZ3RoIC0gMSApO1xyXG5cclxuICAgIC8vIER1cmluZyB0cmF2ZXJzYWwgaW50byB0aGUgc3RyaW5nIG9iamVjdCwgdGhpcyB3aWxsIGhvbGQgdGhlIG9iamVjdCB3aGVyZSB0aGUgbmV4dCBsZXZlbCBuZWVkcyB0byBiZSBkZWZpbmVkLFxyXG4gICAgLy8gd2hldGhlciB0aGF0J3MgYW5vdGhlciBjaGlsZCBvYmplY3QsIG9yIHRoZSBzdHJpbmcgdmFsdWUgaXRzZWxmLlxyXG4gICAgbGV0IHJlZmVyZW5jZTogVFN0cmluZ01vZHVsZSA9IHN0cmluZ01vZHVsZTtcclxuXHJcbiAgICAvLyBXZSdsbCB0cmF2ZXJzZSBkb3duIHRocm91Z2ggdGhlIHBhcnRzIG9mIGEgc3RyaW5nIGtleSAoc2VwYXJhdGVkIGJ5ICcuJyksIGNyZWF0aW5nIGEgbmV3IGxldmVsIGluIHRoZVxyXG4gICAgLy8gc3RyaW5nIG9iamVjdCBmb3IgZWFjaCBvbmUuIFRoaXMgaXMgZG9uZSBmb3IgYWxsIEJVVCB0aGUgbGFzdCBwYXJ0LCBzaW5jZSB3ZSdsbCB3YW50IHRvIGFzc2lnbiB0aGUgcmVzdWx0XHJcbiAgICAvLyBvZiB0aGF0IHRvIGEgcmF3IHN0cmluZyB2YWx1ZSAocmF0aGVyIHRoYW4gYW4gb2JqZWN0KS5cclxuICAgIGxldCBwYXJ0aWFsS2V5ID0gc3RyaW5nS2V5UHJlZml4O1xyXG4gICAgYWxsQnV0TGFzdEtleVBhcnQuZm9yRWFjaCggKCBrZXlQYXJ0LCBpICkgPT4ge1xyXG4gICAgICAvLyBXaGVuIGNvbmNhdGVuYXRpbmcgZWFjaCBsZXZlbCBpbnRvIHRoZSBmaW5hbCBzdHJpbmcga2V5LCB3ZSBkb24ndCB3YW50IHRvIHB1dCBhICcuJyBkaXJlY3RseSBhZnRlciB0aGVcclxuICAgICAgLy8gc2xhc2gsIGJlY2F1c2UgYEpPSVNULy5SZXNldEFsbEJ1dHRvbi5uYW1lYCB3b3VsZCBiZSBpbnZhbGlkLlxyXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL2NoaXBwZXIvaXNzdWVzLzkyMlxyXG4gICAgICBwYXJ0aWFsS2V5ICs9IGAke2kgPiAwID8gJy4nIDogJyd9JHtrZXlQYXJ0fWA7XHJcblxyXG4gICAgICAvLyBEb24ndCBhbGxvdyBlLmcuIEpPSVNUL2EgYW5kIEpPSVNUL2EuYiwgc2luY2UgbG9jYWxlT2JqZWN0LmEgd291bGQgbmVlZCB0byBiZSBhIHN0cmluZyBBTkQgYW4gb2JqZWN0IGF0IHRoZVxyXG4gICAgICAvLyBzYW1lIHRpbWUuXHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIHR5cGVvZiByZWZlcmVuY2VbIGtleVBhcnQgXSAhPT0gJ3N0cmluZycsXHJcbiAgICAgICAgJ0l0IGlzIG5vdCBhbGxvd2VkIHRvIGhhdmUgdHdvIGRpZmZlcmVudCBzdHJpbmcga2V5cyB3aGVyZSBvbmUgaXMgZXh0ZW5kZWQgYnkgYWRkaW5nIGEgcGVyaW9kICguKSBhdCB0aGUgZW5kICcgK1xyXG4gICAgICAgIGBvZiB0aGUgb3RoZXIuIFRoZSBzdHJpbmcga2V5ICR7cGFydGlhbEtleX0gaXMgZXh0ZW5kZWQgYnkgJHtzdHJpbmdLZXl9IGluIHRoaXMgY2FzZSwgYW5kIHNob3VsZCBiZSBjaGFuZ2VkLmAgKTtcclxuXHJcbiAgICAgIC8vIENyZWF0ZSB0aGUgbmV4dCBuZXN0ZWQgbGV2ZWwsIGFuZCBtb3ZlIGludG8gaXRcclxuICAgICAgaWYgKCAhcmVmZXJlbmNlWyBrZXlQYXJ0IF0gKSB7XHJcbiAgICAgICAgcmVmZXJlbmNlWyBrZXlQYXJ0IF0gPSB7fTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmVmZXJlbmNlID0gcmVmZXJlbmNlWyBrZXlQYXJ0IF0gYXMgVFN0cmluZ01vZHVsZTsgLy8gc2luY2Ugd2UgYXJlIG9uIGFsbCBidXQgdGhlIGxhc3Qga2V5IHBhcnQsIGl0IGNhbm5vdCBiZSBzdHJpbmdsaWtlXHJcbiAgICB9ICk7XHJcblxyXG4gICAgYXNzZXJ0ICYmIGFzc2VydCggdHlwZW9mIHJlZmVyZW5jZVsgbGFzdEtleVBhcnQgXSAhPT0gJ29iamVjdCcsXHJcbiAgICAgICdJdCBpcyBub3QgYWxsb3dlZCB0byBoYXZlIHR3byBkaWZmZXJlbnQgc3RyaW5nIGtleXMgd2hlcmUgb25lIGlzIGV4dGVuZGVkIGJ5IGFkZGluZyBhIHBlcmlvZCAoLikgYXQgdGhlIGVuZCAnICtcclxuICAgICAgYG9mIHRoZSBvdGhlci4gVGhlIHN0cmluZyBrZXkgJHtzdHJpbmdLZXl9IGlzIGV4dGVuZGVkIGJ5IGFub3RoZXIga2V5LCBzb21ldGhpbmcgY29udGFpbmluZyAke3JlZmVyZW5jZVsgbGFzdEtleVBhcnQgXSAmJiBPYmplY3Qua2V5cyggcmVmZXJlbmNlWyBsYXN0S2V5UGFydCBdICl9LmAgKTtcclxuICAgIGFzc2VydCAmJiBhc3NlcnQoICFyZWZlcmVuY2VbIGxhc3RLZXlQYXJ0IF0sXHJcbiAgICAgIGBXZSBzaG91bGQgbm90IGhhdmUgZGVmaW5lZCB0aGlzIHBsYWNlIGluIHRoZSBvYmplY3QgKCR7c3RyaW5nS2V5fSksIG90aGVyd2lzZSBpdCBtZWFucyBhIGR1cGxpY2F0ZWQgc3RyaW5nIGtleSBPUiBleHRlbmRlZCBzdHJpbmcga2V5YCApO1xyXG5cclxuICAgIC8vIEluIGNhc2Ugb3VyIGFzc2VydGlvbnMgYXJlIG5vdCBlbmFibGVkLCB3ZSdsbCBuZWVkIHRvIHByb2NlZWQgd2l0aG91dCBmYWlsaW5nIG91dCAoc28gd2UgYWxsb3cgZm9yIHRoZVxyXG4gICAgLy8gZXh0ZW5kZWQgc3RyaW5nIGtleXMgaW4gb3VyIGFjdHVhbCBjb2RlLCBldmVuIHRob3VnaCBhc3NlcnRpb25zIHNob3VsZCBwcmV2ZW50IHRoYXQpLlxyXG4gICAgaWYgKCB0eXBlb2YgcmVmZXJlbmNlICE9PSAnc3RyaW5nJyApIHtcclxuICAgICAgbGV0IHRhbmRlbSA9IFRhbmRlbS5TVFJJTkdTLmNyZWF0ZVRhbmRlbSggXy5jYW1lbENhc2UoIHJlcXVpcmVqc05hbWVzcGFjZSApICk7XHJcbiAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IGtleVBhcnRzLmxlbmd0aDsgaSsrICkge1xyXG5cclxuICAgICAgICBsZXQgdGFuZGVtTmFtZSA9IHN0cmluZ0tleVRvVGFuZGVtTmFtZSgga2V5UGFydHNbIGkgXSApO1xyXG5cclxuICAgICAgICAvLyBJZiBpdCBpcyB0aGUgdGFpbCBvZiB0aGUgc3RyaW5nIGtleSwgdGhlbiBtYWtlIHRoZSB0YW5kZW0gYmUgYSBcIipTdHJpbmdQcm9wZXJ0eVwiXHJcbiAgICAgICAgaWYgKCBpID09PSBrZXlQYXJ0cy5sZW5ndGggLSAxICkge1xyXG5cclxuICAgICAgICAgIGxldCBjdXJyZW50VGFuZGVtTmFtZSA9IHRhbmRlbU5hbWU7XHJcbiAgICAgICAgICBsZXQgaiA9IDA7XHJcbiAgICAgICAgICBsZXQgdGFuZGVtTmFtZVRha2VuID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdHdvIHVuaXF1ZSBzdHJpbmcga2V5cyBtYXAgdG8gdGhlIHNhbWUgY2FtZWwgY2FzZSB2YWx1ZSwgaS5lLiBcIlNvbGlkXCIgYW5kIFwic29saWRcIi5cclxuICAgICAgICAgIC8vIEhlcmUgd2Ugd2lsbCBiZSBzb2xpZFN0cmluZ1Byb3BlcnR5IGFuZCBzb2xpZDJTdHJpbmdQcm9wZXJ0eVxyXG4gICAgICAgICAgd2hpbGUgKCB0YW5kZW1OYW1lVGFrZW4gKSB7XHJcbiAgICAgICAgICAgIGorKztcclxuXHJcbiAgICAgICAgICAgIGN1cnJlbnRUYW5kZW1OYW1lID0gYCR7dGFuZGVtTmFtZX0ke2ogPT09IDEgPyAnJyA6IGp9U3RyaW5nUHJvcGVydHlgO1xyXG5cclxuICAgICAgICAgICAgdGFuZGVtTmFtZVRha2VuID0gdGFuZGVtLmhhc0NoaWxkKCBjdXJyZW50VGFuZGVtTmFtZSApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGFuZGVtTmFtZSA9IGN1cnJlbnRUYW5kZW1OYW1lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGFuZGVtID0gdGFuZGVtLmNyZWF0ZVRhbmRlbSggdGFuZGVtTmFtZSApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBzdHJpbmdzIG5lc3RlZCB1bmRlciB0aGUgYTExeSBzZWN0aW9uIGFyZSBub3QgY3VycmVudGx5IFBoRVQtaU8gaW5zdHJ1bWVudGVkLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL2NoaXBwZXIvaXNzdWVzLzEzNTJcclxuICAgICAgaWYgKCB0YW5kZW0ucGhldGlvSUQuaW5jbHVkZXMoICcuYTExeS4nICkgKSB7XHJcbiAgICAgICAgdGFuZGVtID0gVGFuZGVtLk9QVF9PVVQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGxvY2FsaXplZFN0cmluZyA9IG5ldyBMb2NhbGl6ZWRTdHJpbmcoXHJcbiAgICAgICAgc3RyaW5nS2V5LFxyXG4gICAgICAgIHBoZXQuY2hpcHBlci5tYXBTdHJpbmcoIHBoZXQuY2hpcHBlci5zdHJpbmdzWyBGQUxMQkFDS19MT0NBTEUgXVsgc3RyaW5nS2V5IF0gKSxcclxuICAgICAgICB0YW5kZW0sXHJcbiAgICAgICAgcGhldC5jaGlwcGVyLnN0cmluZ01ldGFkYXRhWyBzdHJpbmdLZXkgXVxyXG4gICAgICApO1xyXG4gICAgICBsb2NhbGl6ZWRTdHJpbmdNYXBbIHN0cmluZ0tleSBdID0gbG9jYWxpemVkU3RyaW5nO1xyXG5cclxuICAgICAgLy8gUHVzaCB1cCB0aGUgdHJhbnNsYXRlZCB2YWx1ZXNcclxuICAgICAgKCBPYmplY3Qua2V5cyggcGhldC5jaGlwcGVyLnN0cmluZ3MgKSBhcyBMb2NhbGVbXSApLmZvckVhY2goICggbG9jYWxlOiBMb2NhbGUgKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc3RyaW5nOiBzdHJpbmcgPSBwaGV0LmNoaXBwZXIuc3RyaW5nc1sgbG9jYWxlIF1bIHN0cmluZ0tleSBdO1xyXG4gICAgICAgIC8vIElnbm9yZSB6ZXJvLWxlbmd0aCBzdHJpbmdzLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL2NoaXBwZXIvaXNzdWVzLzEzNDNcclxuICAgICAgICBpZiAoIHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnICYmIHN0cmluZyAhPT0gJycgKSB7XHJcbiAgICAgICAgICBsb2NhbGl6ZWRTdHJpbmcuc2V0SW5pdGlhbFZhbHVlKCBsb2NhbGUsIHBoZXQuY2hpcHBlci5tYXBTdHJpbmcoIHN0cmluZyApICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9ICk7XHJcblxyXG4gICAgICAvLyBQdXQgb3VyIFByb3BlcnR5IGluIHRoZSBzdHJpbmdNb2R1bGVcclxuICAgICAgcmVmZXJlbmNlWyBgJHtsYXN0S2V5UGFydH1TdHJpbmdQcm9wZXJ0eWAgXSA9IGxvY2FsaXplZFN0cmluZy5wcm9wZXJ0eTtcclxuXHJcbiAgICAgIC8vIENoYW5nZSBvdXIgc3RyaW5nTW9kdWxlIGJhc2VkIG9uIHRoZSBQcm9wZXJ0eSB2YWx1ZVxyXG4gICAgICBsb2NhbGl6ZWRTdHJpbmcucHJvcGVydHkubGluayggc3RyaW5nID0+IHtcclxuICAgICAgICByZWZlcmVuY2VbIGxhc3RLZXlQYXJ0IF0gPSBzdHJpbmc7XHJcbiAgICAgIH0gKTtcclxuICAgIH1cclxuICB9ICk7XHJcblxyXG4gIHJldHVybiBzdHJpbmdNb2R1bGU7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBnZXRTdHJpbmdNb2R1bGU7Il0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFlQSxJQUFBQSxhQUFBLEdBQUFDLHNCQUFB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