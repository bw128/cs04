"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.combineOptions = combineOptions;
exports["default"] = optionize;
exports.optionize3 = optionize3;
exports.optionize4 = optionize4;
var _phetCore = _interopRequireDefault(require("./phetCore.js"));
var _merge = _interopRequireDefault(require("./merge.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
// Copyright 2022-2023, University of Colorado Boulder

/**
 * Optionize is a TypeScript layer built on PHET_CORE/merge. Its goal is to satisfy type safety within PhET's "options"
 * pattern.
 *
 * For up-to-date examples on how to use this file, see WILDER/WilderOptionsPatterns.ts
 *
 * This pattern is still being solidified. Although the long term location of PhET's options pattern documentation
 * can be found at https://github.com/phetsims/phet-info/blob/main/doc/phet-software-design-patterns.md#options-and-config,
 * that document is currently out of date. Please see https://github.com/phetsims/phet-core/issues/128 for current
 * progress on this pattern.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Michael Kauzmann (PhET Interactive Simulations)
 */

// Gets the parts of an object that are optional

// This is the type for the `defaults` argument to optionize

// eslint-disable-line @typescript-eslint/ban-types

// Factor out the merge arrow closure to avoid heap/cpu at runtime
var merge4 = function merge4(a, b, c, d) {
  return (0, _merge["default"])(a, b, c, d);
};

// ProvidedOptions = The type of this class's public API (type of the providedOptions parameter in the constructor)
// SelfOptions = Options that are defined by "this" class. Anything optional in this block must have a default provided in "defaults"
// ParentOptions = The public API for parent options, this will be exported by the parent class, like "NodeOptions"
// KeysUsedInSubclassConstructor = list of keys from ParentOptions that are used in this constructor.
function optionize() {
  return merge4;
}

// Use this function to gain the typing that optionize provides but in a case where the first argument is an empty object.
function optionize3() {
  return merge4;
}

/**
 * Use this function to replace merge in cases like:
 *
 * const options = m-e-r-g-e(
 *   {},
 *
 *   // ParentOptions defaults that are common throughout the sim
 *   MyConstants.SOME_COMMON_OPTIONS,
 *
 *   // SelfOptions and ParentOptions defaults that are provided by this class
 *   { ... },
 *
 *   // option values that are provided by the caller
 *   providedOptions );
 */
function optionize4() {
  return merge4;
}

// Use combineOptions to combine object literals (typically options) that all have the same type.
function combineOptions(target) {
  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }
  return merge4.apply(void 0, [target].concat(sources));
}

// function optionize<ProvidedOptions, // eslint-disable-line no-redeclare
//   SelfOptions = ProvidedOptions,
//   ParentOptions = EmptySelfOptions>():
//   <KeysUsedInSubclassConstructor extends keyof ( ParentOptions )>(
//     emptyObject: ObjectWithNoKeys,
//     defaults: OptionizeDefaults<SelfOptions, ParentOptions>,
//     providedOptions?: ProvidedOptions
//   ) => OptionizeDefaults<SelfOptions, ParentOptions> & ProvidedOptions & Required<Pick<ParentOptions, KeysUsedInSubclassConstructor>>;
//
// function optionize<ProvidedOptions, // eslint-disable-line no-redeclare
//   SelfOptions = ProvidedOptions,
//   ParentOptions = EmptySelfOptions,
//   KeysUsedInSubclassConstructor extends keyof ParentOptions = never>():
//   (
//     empytObject: ObjectWithNoKeys,
//     defaults: OptionizeDefaults<SelfOptions, ParentOptions, KeysUsedInSubclassConstructor>,
//     providedOptions?: ProvidedOptions
//   ) => ObjectWithNoKeys & OptionizeDefaults<SelfOptions, ParentOptions, KeysUsedInSubclassConstructor> & ProvidedOptions;

// The implementation gets "any" types because of the above signatures
// function optionize<???>() { return ( a: any, b?: any, c?: any ) => merge( a, b, c ); } // eslint-disable-line no-redeclare,bad-text

// TypeScript is all-or-none on inferring generic parameter types (per function), so we must use the nested strategy in
// https://stackoverflow.com/questions/63678306/typescript-partial-type-inference to specify the types we want
// while still allowing definitions to flow through.
// This also works, we will keep it here now in case it helps with further improvements with inference.
// const optionize = <S, P, M extends keyof P = never>() => {
//   return <B>( defaults: Required<Options<S>> & Partial<P> & Required<Pick<P, M>>, providedOptions?: B ) => {
//     return merge( defaults, providedOptions );
//   };
// };

/*
Limitation (I):

This gets us half way there, when you have required args to the parent, this makes sure that you don't make
providedOptions optional (with a question mark). We still need a way to note when the required param is specified via the self options.
const optionize = <S, P = EmptySelfOptions, M extends keyof P = never, A = S & P>(
  defaults: Required<Options<S>> & Partial<P> & Required<Pick<P, M>>,
  providedOptions: RequiredKeys<A> extends never ? ( A | undefined ) : A
) => {
  return merge( defaults, providedOptions );
};

TEST TO SEE IF WE CAN GET TYPESCRIPT TO KNOW ABOUT REQUIRED ARGUMENTS TO POTENTIALLY COME FROM EITHER ARG.
const optionize = <S, P = EmptySelfOptions, M extends keyof P = never, A = S & P>() => {
  type FirstArg = Required<Options<S>> & Partial<P> & Required<Pick<P, M>>;
  return (
    defaults: FirstArg,
    //NOT WORKING: If any required elements were in the first arg, then we don't need them here, and potentially can mark providedOptions as a whole as optional
    providedOptions: RequiredKeys<FirstArg> extends never ? RequiredKeys<A> extends never ? ( A | undefined ) : A : A
  ) => {
    return merge( defaults, providedOptions );
  };
};
 */

_phetCore["default"].register('optionize', optionize);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfcGhldENvcmUiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9tZXJnZSIsIm9iaiIsIl9fZXNNb2R1bGUiLCJtZXJnZTQiLCJhIiwiYiIsImMiLCJkIiwibWVyZ2UiLCJvcHRpb25pemUiLCJvcHRpb25pemUzIiwib3B0aW9uaXplNCIsImNvbWJpbmVPcHRpb25zIiwidGFyZ2V0IiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZXMiLCJBcnJheSIsIl9rZXkiLCJhcHBseSIsImNvbmNhdCIsInBoZXRDb3JlIiwicmVnaXN0ZXIiXSwic291cmNlcyI6WyJvcHRpb25pemUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMjItMjAyMywgVW5pdmVyc2l0eSBvZiBDb2xvcmFkbyBCb3VsZGVyXHJcblxyXG4vKipcclxuICogT3B0aW9uaXplIGlzIGEgVHlwZVNjcmlwdCBsYXllciBidWlsdCBvbiBQSEVUX0NPUkUvbWVyZ2UuIEl0cyBnb2FsIGlzIHRvIHNhdGlzZnkgdHlwZSBzYWZldHkgd2l0aGluIFBoRVQncyBcIm9wdGlvbnNcIlxyXG4gKiBwYXR0ZXJuLlxyXG4gKlxyXG4gKiBGb3IgdXAtdG8tZGF0ZSBleGFtcGxlcyBvbiBob3cgdG8gdXNlIHRoaXMgZmlsZSwgc2VlIFdJTERFUi9XaWxkZXJPcHRpb25zUGF0dGVybnMudHNcclxuICpcclxuICogVGhpcyBwYXR0ZXJuIGlzIHN0aWxsIGJlaW5nIHNvbGlkaWZpZWQuIEFsdGhvdWdoIHRoZSBsb25nIHRlcm0gbG9jYXRpb24gb2YgUGhFVCdzIG9wdGlvbnMgcGF0dGVybiBkb2N1bWVudGF0aW9uXHJcbiAqIGNhbiBiZSBmb3VuZCBhdCBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvcGhldC1pbmZvL2Jsb2IvbWFpbi9kb2MvcGhldC1zb2Z0d2FyZS1kZXNpZ24tcGF0dGVybnMubWQjb3B0aW9ucy1hbmQtY29uZmlnLFxyXG4gKiB0aGF0IGRvY3VtZW50IGlzIGN1cnJlbnRseSBvdXQgb2YgZGF0ZS4gUGxlYXNlIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvcGhldC1jb3JlL2lzc3Vlcy8xMjggZm9yIGN1cnJlbnRcclxuICogcHJvZ3Jlc3Mgb24gdGhpcyBwYXR0ZXJuLlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNhbSBSZWlkIChQaEVUIEludGVyYWN0aXZlIFNpbXVsYXRpb25zKVxyXG4gKiBAYXV0aG9yIE1pY2hhZWwgS2F1em1hbm4gKFBoRVQgSW50ZXJhY3RpdmUgU2ltdWxhdGlvbnMpXHJcbiAqL1xyXG5cclxuaW1wb3J0IHBoZXRDb3JlIGZyb20gJy4vcGhldENvcmUuanMnO1xyXG5pbXBvcnQgbWVyZ2UgZnJvbSAnLi9tZXJnZS5qcyc7XHJcbmltcG9ydCBJbnRlbnRpb25hbEFueSBmcm9tICcuL3R5cGVzL0ludGVudGlvbmFsQW55LmpzJztcclxuaW1wb3J0IFJlcXVpcmVkS2V5cyBmcm9tICcuL3R5cGVzL1JlcXVpcmVkS2V5cy5qcyc7XHJcbmltcG9ydCBPcHRpb25hbEtleXMgZnJvbSAnLi90eXBlcy9PcHRpb25hbEtleXMuanMnO1xyXG5cclxuLy8gR2V0cyB0aGUgcGFydHMgb2YgYW4gb2JqZWN0IHRoYXQgYXJlIG9wdGlvbmFsXHJcbnR5cGUgT3B0aW9uczxUPiA9IFBpY2s8VCwgT3B0aW9uYWxLZXlzPFQ+PjtcclxuXHJcbnR5cGUgT2JqZWN0V2l0aE5vS2V5cyA9IFJlY29yZDxzdHJpbmcgfCBudW1iZXIsIG5ldmVyPjtcclxuXHJcbmV4cG9ydCB0eXBlIEVtcHR5U2VsZk9wdGlvbnMgPSB7XHJcbiAgX2VtcHR5U2VsZk9wdGlvbnNLZXk/OiBuZXZlcjtcclxufTtcclxuXHJcbnR5cGUgRW1wdHlTZWxmT3B0aW9uc0tleXMgPSBrZXlvZiBFbXB0eVNlbGZPcHRpb25zO1xyXG5cclxuLy8gVGhpcyBpcyB0aGUgdHlwZSBmb3IgdGhlIGBkZWZhdWx0c2AgYXJndW1lbnQgdG8gb3B0aW9uaXplXHJcbnR5cGUgT3B0aW9uaXplRGVmYXVsdHM8U2VsZk9wdGlvbnMgPSBFbXB0eVNlbGZPcHRpb25zLCBQYXJlbnRPcHRpb25zID0gRW1wdHlTZWxmT3B0aW9ucywgUHJvdmlkZWRPcHRpb25zID0gRW1wdHlTZWxmT3B0aW9ucz4gPVxyXG5cclxuLy8gRXZlcnl0aGluZyBvcHRpb25hbCBmcm9tIFNlbGZPcHRpb25zIG11c3QgaGF2ZSBhIGRlZmF1bHQgc3BlY2lmaWVkXHJcbiAgT21pdDxSZXF1aXJlZDxPcHRpb25zPFNlbGZPcHRpb25zPj4sIEVtcHR5U2VsZk9wdGlvbnNLZXlzPiAmIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xyXG5cclxuICAvLyBBbnl0aGluZyByZXF1aXJlZCBpbiB0aGUgUHJvdmlkZWRPcHRpb25zIHNob3VsZCBub3Qgc2hvdyB1cCBpbiB0aGUgXCJkZWZhdWx0c1wiIG9iamVjdFxyXG4gIHsgW2sgaW4gUmVxdWlyZWRLZXlzPFByb3ZpZGVkT3B0aW9ucz5dPzogbmV2ZXI7IH0gJlxyXG5cclxuICAvLyBBbnkgb3Igbm9uZSBvZiBQYXJlbnQgb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWRcclxuICBQYXJ0aWFsPFBhcmVudE9wdGlvbnM+XHJcblxyXG4gIC8vIEluY2x1ZGUgdGhlIHJlcXVpcmVkIHByb3BlcnRpZXMgZnJvbSBQYXJlbnRPcHRpb25zIHRoYXQgYXJlIG5vdCBpbiB0aGUgUHJvdmlkZWRPcHRpb25zXHJcbiAgJiBSZXF1aXJlZDxPbWl0PFBpY2s8UGFyZW50T3B0aW9ucywgUmVxdWlyZWRLZXlzPFBhcmVudE9wdGlvbnM+PiwgUmVxdWlyZWRLZXlzPFByb3ZpZGVkT3B0aW9ucz4+PjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXHJcblxyXG4vLyBGYWN0b3Igb3V0IHRoZSBtZXJnZSBhcnJvdyBjbG9zdXJlIHRvIGF2b2lkIGhlYXAvY3B1IGF0IHJ1bnRpbWVcclxuY29uc3QgbWVyZ2U0ID0gKCBhOiBJbnRlbnRpb25hbEFueSwgYj86IEludGVudGlvbmFsQW55LCBjPzogSW50ZW50aW9uYWxBbnksIGQ/OiBJbnRlbnRpb25hbEFueSApID0+IG1lcmdlKCBhLCBiLCBjLCBkICk7XHJcblxyXG4vLyBQcm92aWRlZE9wdGlvbnMgPSBUaGUgdHlwZSBvZiB0aGlzIGNsYXNzJ3MgcHVibGljIEFQSSAodHlwZSBvZiB0aGUgcHJvdmlkZWRPcHRpb25zIHBhcmFtZXRlciBpbiB0aGUgY29uc3RydWN0b3IpXHJcbi8vIFNlbGZPcHRpb25zID0gT3B0aW9ucyB0aGF0IGFyZSBkZWZpbmVkIGJ5IFwidGhpc1wiIGNsYXNzLiBBbnl0aGluZyBvcHRpb25hbCBpbiB0aGlzIGJsb2NrIG11c3QgaGF2ZSBhIGRlZmF1bHQgcHJvdmlkZWQgaW4gXCJkZWZhdWx0c1wiXHJcbi8vIFBhcmVudE9wdGlvbnMgPSBUaGUgcHVibGljIEFQSSBmb3IgcGFyZW50IG9wdGlvbnMsIHRoaXMgd2lsbCBiZSBleHBvcnRlZCBieSB0aGUgcGFyZW50IGNsYXNzLCBsaWtlIFwiTm9kZU9wdGlvbnNcIlxyXG4vLyBLZXlzVXNlZEluU3ViY2xhc3NDb25zdHJ1Y3RvciA9IGxpc3Qgb2Yga2V5cyBmcm9tIFBhcmVudE9wdGlvbnMgdGhhdCBhcmUgdXNlZCBpbiB0aGlzIGNvbnN0cnVjdG9yLlxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvcHRpb25pemU8UHJvdmlkZWRPcHRpb25zLFxyXG4gIFNlbGZPcHRpb25zID0gUHJvdmlkZWRPcHRpb25zLCAvLyBCeSBkZWZhdWx0LCBldmVyeSBvcHRpb25hbCBvcHRpb24gaW4gdGhlIFByb3ZpZGVkT3B0aW9ucyBtdXN0IGhhdmUgYSBkZWZhdWx0IHVubGVzcyB5b3Ugc3BlY2lmeSBhbm90aGVyIG9iamVjdCBmb3IgU2VsZk9wdGlvbnNcclxuICBQYXJlbnRPcHRpb25zID0gUmVjb3JkPG5ldmVyLCBuZXZlcj4+KCk6XHJcbiAgPEtleXNVc2VkSW5TdWJjbGFzc0NvbnN0cnVjdG9yIGV4dGVuZHMga2V5b2YgKCBQYXJlbnRPcHRpb25zICk+KFxyXG4gICAgZGVmYXVsdHM6IE9wdGlvbml6ZURlZmF1bHRzPFNlbGZPcHRpb25zLCBQYXJlbnRPcHRpb25zLCBQcm92aWRlZE9wdGlvbnM+LFxyXG4gICAgcHJvdmlkZWRPcHRpb25zPzogUHJvdmlkZWRPcHRpb25zXHJcbiAgKSA9PiBPcHRpb25pemVEZWZhdWx0czxTZWxmT3B0aW9ucywgUGFyZW50T3B0aW9ucz4gJiBQcm92aWRlZE9wdGlvbnMgJiBSZXF1aXJlZDxQaWNrPFBhcmVudE9wdGlvbnMsIEtleXNVc2VkSW5TdWJjbGFzc0NvbnN0cnVjdG9yPj4ge1xyXG4gIHJldHVybiBtZXJnZTQ7XHJcbn1cclxuXHJcbi8vIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIGdhaW4gdGhlIHR5cGluZyB0aGF0IG9wdGlvbml6ZSBwcm92aWRlcyBidXQgaW4gYSBjYXNlIHdoZXJlIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhbiBlbXB0eSBvYmplY3QuXHJcbmV4cG9ydCBmdW5jdGlvbiBvcHRpb25pemUzPFByb3ZpZGVkT3B0aW9ucyxcclxuICBTZWxmT3B0aW9ucyA9IFByb3ZpZGVkT3B0aW9ucywgLy8gQnkgZGVmYXVsdCwgZXZlcnkgb3B0aW9uYWwgb3B0aW9uIGluIHRoZSBQcm92aWRlZE9wdGlvbnMgbXVzdCBoYXZlIGEgZGVmYXVsdCB1bmxlc3MgeW91IHNwZWNpZnkgYW5vdGhlciBvYmplY3QgZm9yIFNlbGZPcHRpb25zXHJcbiAgUGFyZW50T3B0aW9ucyA9IFJlY29yZDxuZXZlciwgbmV2ZXI+PigpOlxyXG4gIDxLZXlzVXNlZEluU3ViY2xhc3NDb25zdHJ1Y3RvciBleHRlbmRzIGtleW9mICggUGFyZW50T3B0aW9ucyApPihcclxuICAgIGVtcHR5T2JqZWN0OiBPYmplY3RXaXRoTm9LZXlzLFxyXG4gICAgZGVmYXVsdHM6IE9wdGlvbml6ZURlZmF1bHRzPFNlbGZPcHRpb25zLCBQYXJlbnRPcHRpb25zPixcclxuICAgIHByb3ZpZGVkT3B0aW9ucz86IFByb3ZpZGVkT3B0aW9uc1xyXG4gICkgPT4gT3B0aW9uaXplRGVmYXVsdHM8U2VsZk9wdGlvbnMsIFBhcmVudE9wdGlvbnM+ICYgUHJvdmlkZWRPcHRpb25zICYgUmVxdWlyZWQ8UGljazxQYXJlbnRPcHRpb25zLCBLZXlzVXNlZEluU3ViY2xhc3NDb25zdHJ1Y3Rvcj4+IHtcclxuICByZXR1cm4gbWVyZ2U0O1xyXG59XHJcblxyXG4vKipcclxuICogVXNlIHRoaXMgZnVuY3Rpb24gdG8gcmVwbGFjZSBtZXJnZSBpbiBjYXNlcyBsaWtlOlxyXG4gKlxyXG4gKiBjb25zdCBvcHRpb25zID0gbS1lLXItZy1lKFxyXG4gKiAgIHt9LFxyXG4gKlxyXG4gKiAgIC8vIFBhcmVudE9wdGlvbnMgZGVmYXVsdHMgdGhhdCBhcmUgY29tbW9uIHRocm91Z2hvdXQgdGhlIHNpbVxyXG4gKiAgIE15Q29uc3RhbnRzLlNPTUVfQ09NTU9OX09QVElPTlMsXHJcbiAqXHJcbiAqICAgLy8gU2VsZk9wdGlvbnMgYW5kIFBhcmVudE9wdGlvbnMgZGVmYXVsdHMgdGhhdCBhcmUgcHJvdmlkZWQgYnkgdGhpcyBjbGFzc1xyXG4gKiAgIHsgLi4uIH0sXHJcbiAqXHJcbiAqICAgLy8gb3B0aW9uIHZhbHVlcyB0aGF0IGFyZSBwcm92aWRlZCBieSB0aGUgY2FsbGVyXHJcbiAqICAgcHJvdmlkZWRPcHRpb25zICk7XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gb3B0aW9uaXplNDxQcm92aWRlZE9wdGlvbnMsXHJcbiAgU2VsZk9wdGlvbnMgPSBQcm92aWRlZE9wdGlvbnMsXHJcbiAgUGFyZW50T3B0aW9ucyA9IG9iamVjdD4oKTpcclxuICA8S2V5c1VzZWRJblN1YmNsYXNzQ29uc3RydWN0b3IgZXh0ZW5kcyBrZXlvZiAoIFBhcmVudE9wdGlvbnMgKT4oXHJcbiAgICBlbXB0eU9iamVjdDogT2JqZWN0V2l0aE5vS2V5cyxcclxuICAgIGRlZmF1bHRzMTogUGFydGlhbDxQYXJlbnRPcHRpb25zPixcclxuICAgIGRlZmF1bHRzMjogT3B0aW9uaXplRGVmYXVsdHM8U2VsZk9wdGlvbnMsIFBhcmVudE9wdGlvbnM+LFxyXG4gICAgcHJvdmlkZWRPcHRpb25zPzogUHJvdmlkZWRPcHRpb25zXHJcbiAgKSA9PiBPcHRpb25pemVEZWZhdWx0czxTZWxmT3B0aW9ucywgUGFyZW50T3B0aW9ucz4gJiBQcm92aWRlZE9wdGlvbnMgJiBSZXF1aXJlZDxQaWNrPFBhcmVudE9wdGlvbnMsIEtleXNVc2VkSW5TdWJjbGFzc0NvbnN0cnVjdG9yPj4ge1xyXG4gIHJldHVybiBtZXJnZTQ7XHJcbn1cclxuXHJcbi8vIFVzZSBjb21iaW5lT3B0aW9ucyB0byBjb21iaW5lIG9iamVjdCBsaXRlcmFscyAodHlwaWNhbGx5IG9wdGlvbnMpIHRoYXQgYWxsIGhhdmUgdGhlIHNhbWUgdHlwZS5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVPcHRpb25zPFR5cGUgZXh0ZW5kcyBvYmplY3Q+KCB0YXJnZXQ6IFBhcnRpYWw8VHlwZT4sIC4uLnNvdXJjZXM6IEFycmF5PFBhcnRpYWw8VHlwZT4gfCB1bmRlZmluZWQ+ICk6IFR5cGUge1xyXG4gIHJldHVybiBtZXJnZTQoIHRhcmdldCwgLi4uc291cmNlcyApO1xyXG59XHJcblxyXG5cclxuLy8gZnVuY3Rpb24gb3B0aW9uaXplPFByb3ZpZGVkT3B0aW9ucywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZWRlY2xhcmVcclxuLy8gICBTZWxmT3B0aW9ucyA9IFByb3ZpZGVkT3B0aW9ucyxcclxuLy8gICBQYXJlbnRPcHRpb25zID0gRW1wdHlTZWxmT3B0aW9ucz4oKTpcclxuLy8gICA8S2V5c1VzZWRJblN1YmNsYXNzQ29uc3RydWN0b3IgZXh0ZW5kcyBrZXlvZiAoIFBhcmVudE9wdGlvbnMgKT4oXHJcbi8vICAgICBlbXB0eU9iamVjdDogT2JqZWN0V2l0aE5vS2V5cyxcclxuLy8gICAgIGRlZmF1bHRzOiBPcHRpb25pemVEZWZhdWx0czxTZWxmT3B0aW9ucywgUGFyZW50T3B0aW9ucz4sXHJcbi8vICAgICBwcm92aWRlZE9wdGlvbnM/OiBQcm92aWRlZE9wdGlvbnNcclxuLy8gICApID0+IE9wdGlvbml6ZURlZmF1bHRzPFNlbGZPcHRpb25zLCBQYXJlbnRPcHRpb25zPiAmIFByb3ZpZGVkT3B0aW9ucyAmIFJlcXVpcmVkPFBpY2s8UGFyZW50T3B0aW9ucywgS2V5c1VzZWRJblN1YmNsYXNzQ29uc3RydWN0b3I+PjtcclxuLy9cclxuLy8gZnVuY3Rpb24gb3B0aW9uaXplPFByb3ZpZGVkT3B0aW9ucywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZWRlY2xhcmVcclxuLy8gICBTZWxmT3B0aW9ucyA9IFByb3ZpZGVkT3B0aW9ucyxcclxuLy8gICBQYXJlbnRPcHRpb25zID0gRW1wdHlTZWxmT3B0aW9ucyxcclxuLy8gICBLZXlzVXNlZEluU3ViY2xhc3NDb25zdHJ1Y3RvciBleHRlbmRzIGtleW9mIFBhcmVudE9wdGlvbnMgPSBuZXZlcj4oKTpcclxuLy8gICAoXHJcbi8vICAgICBlbXB5dE9iamVjdDogT2JqZWN0V2l0aE5vS2V5cyxcclxuLy8gICAgIGRlZmF1bHRzOiBPcHRpb25pemVEZWZhdWx0czxTZWxmT3B0aW9ucywgUGFyZW50T3B0aW9ucywgS2V5c1VzZWRJblN1YmNsYXNzQ29uc3RydWN0b3I+LFxyXG4vLyAgICAgcHJvdmlkZWRPcHRpb25zPzogUHJvdmlkZWRPcHRpb25zXHJcbi8vICAgKSA9PiBPYmplY3RXaXRoTm9LZXlzICYgT3B0aW9uaXplRGVmYXVsdHM8U2VsZk9wdGlvbnMsIFBhcmVudE9wdGlvbnMsIEtleXNVc2VkSW5TdWJjbGFzc0NvbnN0cnVjdG9yPiAmIFByb3ZpZGVkT3B0aW9ucztcclxuXHJcbi8vIFRoZSBpbXBsZW1lbnRhdGlvbiBnZXRzIFwiYW55XCIgdHlwZXMgYmVjYXVzZSBvZiB0aGUgYWJvdmUgc2lnbmF0dXJlc1xyXG4vLyBmdW5jdGlvbiBvcHRpb25pemU8Pz8/PigpIHsgcmV0dXJuICggYTogYW55LCBiPzogYW55LCBjPzogYW55ICkgPT4gbWVyZ2UoIGEsIGIsIGMgKTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlZGVjbGFyZSxiYWQtdGV4dFxyXG5cclxuLy8gVHlwZVNjcmlwdCBpcyBhbGwtb3Itbm9uZSBvbiBpbmZlcnJpbmcgZ2VuZXJpYyBwYXJhbWV0ZXIgdHlwZXMgKHBlciBmdW5jdGlvbiksIHNvIHdlIG11c3QgdXNlIHRoZSBuZXN0ZWQgc3RyYXRlZ3kgaW5cclxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjM2NzgzMDYvdHlwZXNjcmlwdC1wYXJ0aWFsLXR5cGUtaW5mZXJlbmNlIHRvIHNwZWNpZnkgdGhlIHR5cGVzIHdlIHdhbnRcclxuLy8gd2hpbGUgc3RpbGwgYWxsb3dpbmcgZGVmaW5pdGlvbnMgdG8gZmxvdyB0aHJvdWdoLlxyXG4vLyBUaGlzIGFsc28gd29ya3MsIHdlIHdpbGwga2VlcCBpdCBoZXJlIG5vdyBpbiBjYXNlIGl0IGhlbHBzIHdpdGggZnVydGhlciBpbXByb3ZlbWVudHMgd2l0aCBpbmZlcmVuY2UuXHJcbi8vIGNvbnN0IG9wdGlvbml6ZSA9IDxTLCBQLCBNIGV4dGVuZHMga2V5b2YgUCA9IG5ldmVyPigpID0+IHtcclxuLy8gICByZXR1cm4gPEI+KCBkZWZhdWx0czogUmVxdWlyZWQ8T3B0aW9uczxTPj4gJiBQYXJ0aWFsPFA+ICYgUmVxdWlyZWQ8UGljazxQLCBNPj4sIHByb3ZpZGVkT3B0aW9ucz86IEIgKSA9PiB7XHJcbi8vICAgICByZXR1cm4gbWVyZ2UoIGRlZmF1bHRzLCBwcm92aWRlZE9wdGlvbnMgKTtcclxuLy8gICB9O1xyXG4vLyB9O1xyXG5cclxuLypcclxuTGltaXRhdGlvbiAoSSk6XHJcblxyXG5UaGlzIGdldHMgdXMgaGFsZiB3YXkgdGhlcmUsIHdoZW4geW91IGhhdmUgcmVxdWlyZWQgYXJncyB0byB0aGUgcGFyZW50LCB0aGlzIG1ha2VzIHN1cmUgdGhhdCB5b3UgZG9uJ3QgbWFrZVxyXG5wcm92aWRlZE9wdGlvbnMgb3B0aW9uYWwgKHdpdGggYSBxdWVzdGlvbiBtYXJrKS4gV2Ugc3RpbGwgbmVlZCBhIHdheSB0byBub3RlIHdoZW4gdGhlIHJlcXVpcmVkIHBhcmFtIGlzIHNwZWNpZmllZCB2aWEgdGhlIHNlbGYgb3B0aW9ucy5cclxuY29uc3Qgb3B0aW9uaXplID0gPFMsIFAgPSBFbXB0eVNlbGZPcHRpb25zLCBNIGV4dGVuZHMga2V5b2YgUCA9IG5ldmVyLCBBID0gUyAmIFA+KFxyXG4gIGRlZmF1bHRzOiBSZXF1aXJlZDxPcHRpb25zPFM+PiAmIFBhcnRpYWw8UD4gJiBSZXF1aXJlZDxQaWNrPFAsIE0+PixcclxuICBwcm92aWRlZE9wdGlvbnM6IFJlcXVpcmVkS2V5czxBPiBleHRlbmRzIG5ldmVyID8gKCBBIHwgdW5kZWZpbmVkICkgOiBBXHJcbikgPT4ge1xyXG4gIHJldHVybiBtZXJnZSggZGVmYXVsdHMsIHByb3ZpZGVkT3B0aW9ucyApO1xyXG59O1xyXG5cclxuVEVTVCBUTyBTRUUgSUYgV0UgQ0FOIEdFVCBUWVBFU0NSSVBUIFRPIEtOT1cgQUJPVVQgUkVRVUlSRUQgQVJHVU1FTlRTIFRPIFBPVEVOVElBTExZIENPTUUgRlJPTSBFSVRIRVIgQVJHLlxyXG5jb25zdCBvcHRpb25pemUgPSA8UywgUCA9IEVtcHR5U2VsZk9wdGlvbnMsIE0gZXh0ZW5kcyBrZXlvZiBQID0gbmV2ZXIsIEEgPSBTICYgUD4oKSA9PiB7XHJcbiAgdHlwZSBGaXJzdEFyZyA9IFJlcXVpcmVkPE9wdGlvbnM8Uz4+ICYgUGFydGlhbDxQPiAmIFJlcXVpcmVkPFBpY2s8UCwgTT4+O1xyXG4gIHJldHVybiAoXHJcbiAgICBkZWZhdWx0czogRmlyc3RBcmcsXHJcbiAgICAvL05PVCBXT1JLSU5HOiBJZiBhbnkgcmVxdWlyZWQgZWxlbWVudHMgd2VyZSBpbiB0aGUgZmlyc3QgYXJnLCB0aGVuIHdlIGRvbid0IG5lZWQgdGhlbSBoZXJlLCBhbmQgcG90ZW50aWFsbHkgY2FuIG1hcmsgcHJvdmlkZWRPcHRpb25zIGFzIGEgd2hvbGUgYXMgb3B0aW9uYWxcclxuICAgIHByb3ZpZGVkT3B0aW9uczogUmVxdWlyZWRLZXlzPEZpcnN0QXJnPiBleHRlbmRzIG5ldmVyID8gUmVxdWlyZWRLZXlzPEE+IGV4dGVuZHMgbmV2ZXIgPyAoIEEgfCB1bmRlZmluZWQgKSA6IEEgOiBBXHJcbiAgKSA9PiB7XHJcbiAgICByZXR1cm4gbWVyZ2UoIGRlZmF1bHRzLCBwcm92aWRlZE9wdGlvbnMgKTtcclxuICB9O1xyXG59O1xyXG4gKi9cclxuXHJcbnBoZXRDb3JlLnJlZ2lzdGVyKCAnb3B0aW9uaXplJywgb3B0aW9uaXplICk7XHJcbmV4cG9ydCB0eXBlIHsgT3B0aW9uaXplRGVmYXVsdHMgfTsiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQWlCQSxJQUFBQSxTQUFBLEdBQUFDLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBQyxNQUFBLEdBQUFGLHNCQUFBLENBQUFDLE9BQUE7QUFBK0IsU0FBQUQsdUJBQUFHLEdBQUEsV0FBQUEsR0FBQSxJQUFBQSxHQUFBLENBQUFDLFVBQUEsR0FBQUQsR0FBQSxnQkFBQUEsR0FBQTtBQWxCL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFRQTs7QUFXQTs7QUFhcUc7O0FBRXJHO0FBQ0EsSUFBTUUsTUFBTSxHQUFHLFNBQVRBLE1BQU1BLENBQUtDLENBQWlCLEVBQUVDLENBQWtCLEVBQUVDLENBQWtCLEVBQUVDLENBQWtCO0VBQUEsT0FBTSxJQUFBQyxpQkFBSyxFQUFFSixDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFFLENBQUM7QUFBQTs7QUFFdkg7QUFDQTtBQUNBO0FBQ0E7QUFDZSxTQUFTRSxTQUFTQSxDQUFBLEVBTXFHO0VBQ3BJLE9BQU9OLE1BQU07QUFDZjs7QUFFQTtBQUNPLFNBQVNPLFVBQVVBLENBQUEsRUFPNEc7RUFDcEksT0FBT1AsTUFBTTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVNRLFVBQVVBLENBQUEsRUFRNEc7RUFDcEksT0FBT1IsTUFBTTtBQUNmOztBQUVBO0FBQ08sU0FBU1MsY0FBY0EsQ0FBdUJDLE1BQXFCLEVBQXVEO0VBQUEsU0FBQUMsSUFBQSxHQUFBQyxTQUFBLENBQUFDLE1BQUEsRUFBbERDLE9BQU8sT0FBQUMsS0FBQSxDQUFBSixJQUFBLE9BQUFBLElBQUEsV0FBQUssSUFBQSxNQUFBQSxJQUFBLEdBQUFMLElBQUEsRUFBQUssSUFBQTtJQUFQRixPQUFPLENBQUFFLElBQUEsUUFBQUosU0FBQSxDQUFBSSxJQUFBO0VBQUE7RUFDcEYsT0FBT2hCLE1BQU0sQ0FBQWlCLEtBQUEsVUFBRVAsTUFBTSxFQUFBUSxNQUFBLENBQUtKLE9BQU8sQ0FBQyxDQUFDO0FBQ3JDOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUFLLG9CQUFRLENBQUNDLFFBQVEsQ0FBRSxXQUFXLEVBQUVkLFNBQVUsQ0FBQyIsImlnbm9yZUxpc3QiOltdfQ==