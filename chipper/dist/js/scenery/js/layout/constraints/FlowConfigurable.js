// Copyright 2022-2024, University of Colorado Boulder

/**
 * Mixin for storing options that can affect each cell. `null` for values usually means "inherit from the default".
 *
 * Handles a lot of conversion from internal Enumeration values (for performance) and external string representations.
 * This is done primarily for performance and that style of internal enumeration pattern. If string comparisons are
 * faster, that could be used instead.
 *
 * NOTE: Internal non-string representations are also orientation-agnostic - thus "left" and "top" map to the same
 * "start" internally, and thus the external value will appear to "switch" depending on the orientation.
 *
 * NOTE: This is mixed into both the constraint AND the cell, since we have two layers of options. The `null` meaning
 * "inherit from the default" is mainly used for the cells, so that if it's not specified in the cell, it will be
 * specified in the constraint (as non-null).
 *
 * NOTE: This is a mixin meant to be used internally only by Scenery (for the constraint and cell), and should not be
 * used by outside code.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

import TinyEmitter from '../../../../axon/js/TinyEmitter.js';
import Orientation from '../../../../phet-core/js/Orientation.js';
import memoize from '../../../../phet-core/js/memoize.js';
import mutate from '../../../../phet-core/js/mutate.js';
import { LayoutAlign, MARGIN_LAYOUT_CONFIGURABLE_OPTION_KEYS, MarginLayoutConfigurable, scenery } from '../../imports.js';
const FLOW_CONFIGURABLE_OPTION_KEYS = ['orientation', 'align', 'stretch', 'grow'].concat(MARGIN_LAYOUT_CONFIGURABLE_OPTION_KEYS);

// We remove the null values for the values that won't actually take null

// (scenery-internal)
const FlowConfigurable = memoize(Type => {
  return class FlowConfigurableMixin extends MarginLayoutConfigurable(Type) {
    // @mixin-protected - made public for use in the mixin only
    _orientation = Orientation.HORIZONTAL;

    // (scenery-internal)
    _align = null;
    _stretch = null;
    _grow = null;
    orientationChangedEmitter = new TinyEmitter();

    /**
     * (scenery-internal)
     */
    constructor(...args) {
      super(...args);
    }

    /**
     * (scenery-internal)
     */
    mutateConfigurable(options) {
      super.mutateConfigurable(options);
      mutate(this, FLOW_CONFIGURABLE_OPTION_KEYS, options);
    }

    /**
     * Resets values to the "base" state.
     *
     * This is the fallback state for a constraint where every value is defined and valid. If a cell does not have a
     * specific "overridden" value, or a constraint doesn't have an "overridden" value, then it will take the value
     * defined here.
     *
     * These should be the default values for constraints.
     *
     * (scenery-internal)
     */
    setConfigToBaseDefault() {
      this._align = LayoutAlign.CENTER;
      this._stretch = false;
      this._grow = 0;
      super.setConfigToBaseDefault();
    }

    /**
     * Resets values to the "don't override anything, only inherit from the constraint" state
     *
     * These should be the default values for cells (e.g. "take all the behavior from the constraint, nothing is
     * overridden").
     *
     * (scenery-internal)
     */
    setConfigToInherit() {
      this._align = null;
      this._stretch = null;
      this._grow = null;
      super.setConfigToInherit();
    }

    /**
     * (scenery-internal)
     */
    get orientation() {
      return this._orientation === Orientation.HORIZONTAL ? 'horizontal' : 'vertical';
    }

    /**
     * (scenery-internal)
     */
    set orientation(value) {
      assert && assert(value === 'horizontal' || value === 'vertical');
      const enumOrientation = value === 'horizontal' ? Orientation.HORIZONTAL : Orientation.VERTICAL;
      if (this._orientation !== enumOrientation) {
        this._orientation = enumOrientation;
        this.orientationChangedEmitter.emit();
        this.changedEmitter.emit();
      }
    }

    /**
     * (scenery-internal)
     */
    get align() {
      const result = LayoutAlign.internalToAlign(this._orientation, this._align);
      assert && assert(result === null || typeof result === 'string');
      return result;
    }

    /**
     * (scenery-internal)
     */
    set align(value) {
      assert && assert(LayoutAlign.getAllowedAligns(this._orientation.opposite).includes(value), `align ${value} not supported, with the orientation ${this._orientation}, the valid values are ${LayoutAlign.getAllowedAligns(this._orientation.opposite)}`);

      // remapping align values to an independent set, so they aren't orientation-dependent
      const mappedValue = LayoutAlign.alignToInternal(this._orientation.opposite, value);
      assert && assert(mappedValue === null || mappedValue instanceof LayoutAlign);
      if (this._align !== mappedValue) {
        this._align = mappedValue;
        this.changedEmitter.emit();
      }
    }

    /**
     * (scenery-internal)
     */
    get stretch() {
      return this._stretch;
    }

    /**
     * (scenery-internal)
     */
    set stretch(value) {
      if (this._stretch !== value) {
        this._stretch = value;
        this.changedEmitter.emit();
      }
    }

    /**
     * (scenery-internal)
     */
    get grow() {
      return this._grow;
    }

    /**
     * (scenery-internal)
     */
    set grow(value) {
      assert && assert(value === null || typeof value === 'number' && isFinite(value) && value >= 0);
      if (this._grow !== value) {
        this._grow = value;
        this.changedEmitter.emit();
      }
    }
  };
});
scenery.register('FlowConfigurable', FlowConfigurable);
export default FlowConfigurable;
export { FLOW_CONFIGURABLE_OPTION_KEYS };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJUaW55RW1pdHRlciIsIk9yaWVudGF0aW9uIiwibWVtb2l6ZSIsIm11dGF0ZSIsIkxheW91dEFsaWduIiwiTUFSR0lOX0xBWU9VVF9DT05GSUdVUkFCTEVfT1BUSU9OX0tFWVMiLCJNYXJnaW5MYXlvdXRDb25maWd1cmFibGUiLCJzY2VuZXJ5IiwiRkxPV19DT05GSUdVUkFCTEVfT1BUSU9OX0tFWVMiLCJjb25jYXQiLCJGbG93Q29uZmlndXJhYmxlIiwiVHlwZSIsIkZsb3dDb25maWd1cmFibGVNaXhpbiIsIl9vcmllbnRhdGlvbiIsIkhPUklaT05UQUwiLCJfYWxpZ24iLCJfc3RyZXRjaCIsIl9ncm93Iiwib3JpZW50YXRpb25DaGFuZ2VkRW1pdHRlciIsImNvbnN0cnVjdG9yIiwiYXJncyIsIm11dGF0ZUNvbmZpZ3VyYWJsZSIsIm9wdGlvbnMiLCJzZXRDb25maWdUb0Jhc2VEZWZhdWx0IiwiQ0VOVEVSIiwic2V0Q29uZmlnVG9Jbmhlcml0Iiwib3JpZW50YXRpb24iLCJ2YWx1ZSIsImFzc2VydCIsImVudW1PcmllbnRhdGlvbiIsIlZFUlRJQ0FMIiwiZW1pdCIsImNoYW5nZWRFbWl0dGVyIiwiYWxpZ24iLCJyZXN1bHQiLCJpbnRlcm5hbFRvQWxpZ24iLCJnZXRBbGxvd2VkQWxpZ25zIiwib3Bwb3NpdGUiLCJpbmNsdWRlcyIsIm1hcHBlZFZhbHVlIiwiYWxpZ25Ub0ludGVybmFsIiwic3RyZXRjaCIsImdyb3ciLCJpc0Zpbml0ZSIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiRmxvd0NvbmZpZ3VyYWJsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMi0yMDI0LCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBNaXhpbiBmb3Igc3RvcmluZyBvcHRpb25zIHRoYXQgY2FuIGFmZmVjdCBlYWNoIGNlbGwuIGBudWxsYCBmb3IgdmFsdWVzIHVzdWFsbHkgbWVhbnMgXCJpbmhlcml0IGZyb20gdGhlIGRlZmF1bHRcIi5cclxuICpcclxuICogSGFuZGxlcyBhIGxvdCBvZiBjb252ZXJzaW9uIGZyb20gaW50ZXJuYWwgRW51bWVyYXRpb24gdmFsdWVzIChmb3IgcGVyZm9ybWFuY2UpIGFuZCBleHRlcm5hbCBzdHJpbmcgcmVwcmVzZW50YXRpb25zLlxyXG4gKiBUaGlzIGlzIGRvbmUgcHJpbWFyaWx5IGZvciBwZXJmb3JtYW5jZSBhbmQgdGhhdCBzdHlsZSBvZiBpbnRlcm5hbCBlbnVtZXJhdGlvbiBwYXR0ZXJuLiBJZiBzdHJpbmcgY29tcGFyaXNvbnMgYXJlXHJcbiAqIGZhc3RlciwgdGhhdCBjb3VsZCBiZSB1c2VkIGluc3RlYWQuXHJcbiAqXHJcbiAqIE5PVEU6IEludGVybmFsIG5vbi1zdHJpbmcgcmVwcmVzZW50YXRpb25zIGFyZSBhbHNvIG9yaWVudGF0aW9uLWFnbm9zdGljIC0gdGh1cyBcImxlZnRcIiBhbmQgXCJ0b3BcIiBtYXAgdG8gdGhlIHNhbWVcclxuICogXCJzdGFydFwiIGludGVybmFsbHksIGFuZCB0aHVzIHRoZSBleHRlcm5hbCB2YWx1ZSB3aWxsIGFwcGVhciB0byBcInN3aXRjaFwiIGRlcGVuZGluZyBvbiB0aGUgb3JpZW50YXRpb24uXHJcbiAqXHJcbiAqIE5PVEU6IFRoaXMgaXMgbWl4ZWQgaW50byBib3RoIHRoZSBjb25zdHJhaW50IEFORCB0aGUgY2VsbCwgc2luY2Ugd2UgaGF2ZSB0d28gbGF5ZXJzIG9mIG9wdGlvbnMuIFRoZSBgbnVsbGAgbWVhbmluZ1xyXG4gKiBcImluaGVyaXQgZnJvbSB0aGUgZGVmYXVsdFwiIGlzIG1haW5seSB1c2VkIGZvciB0aGUgY2VsbHMsIHNvIHRoYXQgaWYgaXQncyBub3Qgc3BlY2lmaWVkIGluIHRoZSBjZWxsLCBpdCB3aWxsIGJlXHJcbiAqIHNwZWNpZmllZCBpbiB0aGUgY29uc3RyYWludCAoYXMgbm9uLW51bGwpLlxyXG4gKlxyXG4gKiBOT1RFOiBUaGlzIGlzIGEgbWl4aW4gbWVhbnQgdG8gYmUgdXNlZCBpbnRlcm5hbGx5IG9ubHkgYnkgU2NlbmVyeSAoZm9yIHRoZSBjb25zdHJhaW50IGFuZCBjZWxsKSwgYW5kIHNob3VsZCBub3QgYmVcclxuICogdXNlZCBieSBvdXRzaWRlIGNvZGUuXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9uYXRoYW4gT2xzb24gPGpvbmF0aGFuLm9sc29uQGNvbG9yYWRvLmVkdT5cclxuICovXHJcblxyXG5pbXBvcnQgVGlueUVtaXR0ZXIgZnJvbSAnLi4vLi4vLi4vLi4vYXhvbi9qcy9UaW55RW1pdHRlci5qcyc7XHJcbmltcG9ydCBPcmllbnRhdGlvbiBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvT3JpZW50YXRpb24uanMnO1xyXG5pbXBvcnQgbWVtb2l6ZSBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvbWVtb2l6ZS5qcyc7XHJcbmltcG9ydCBtdXRhdGUgZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL211dGF0ZS5qcyc7XHJcbmltcG9ydCB7IEhvcml6b250YWxMYXlvdXRBbGlnbiwgTGF5b3V0QWxpZ24sIExheW91dE9yaWVudGF0aW9uLCBNQVJHSU5fTEFZT1VUX0NPTkZJR1VSQUJMRV9PUFRJT05fS0VZUywgTWFyZ2luTGF5b3V0Q29uZmlndXJhYmxlLCBNYXJnaW5MYXlvdXRDb25maWd1cmFibGVPcHRpb25zLCBzY2VuZXJ5LCBWZXJ0aWNhbExheW91dEFsaWduIH0gZnJvbSAnLi4vLi4vaW1wb3J0cy5qcyc7XHJcbmltcG9ydCBDb25zdHJ1Y3RvciBmcm9tICcuLi8uLi8uLi8uLi9waGV0LWNvcmUvanMvdHlwZXMvQ29uc3RydWN0b3IuanMnO1xyXG5pbXBvcnQgV2l0aG91dE51bGwgZnJvbSAnLi4vLi4vLi4vLi4vcGhldC1jb3JlL2pzL3R5cGVzL1dpdGhvdXROdWxsLmpzJztcclxuaW1wb3J0IEludGVudGlvbmFsQW55IGZyb20gJy4uLy4uLy4uLy4uL3BoZXQtY29yZS9qcy90eXBlcy9JbnRlbnRpb25hbEFueS5qcyc7XHJcbmltcG9ydCBURW1pdHRlciBmcm9tICcuLi8uLi8uLi8uLi9heG9uL2pzL1RFbWl0dGVyLmpzJztcclxuaW1wb3J0IHsgVE1hcmdpbkxheW91dENvbmZpZ3VyYWJsZSB9IGZyb20gJy4vTWFyZ2luTGF5b3V0Q29uZmlndXJhYmxlLmpzJztcclxuXHJcbmNvbnN0IEZMT1dfQ09ORklHVVJBQkxFX09QVElPTl9LRVlTID0gW1xyXG4gICdvcmllbnRhdGlvbicsXHJcbiAgJ2FsaWduJyxcclxuICAnc3RyZXRjaCcsXHJcbiAgJ2dyb3cnXHJcbl0uY29uY2F0KCBNQVJHSU5fTEFZT1VUX0NPTkZJR1VSQUJMRV9PUFRJT05fS0VZUyApO1xyXG5cclxudHlwZSBTZWxmT3B0aW9ucyA9IHtcclxuICAvLyBUaGUgbWFpbiBvcmllbnRhdGlvbiBvZiB0aGUgbGF5b3V0IHRoYXQgdGFrZXMgcGxhY2UuIEl0ZW1zIHdpbGwgYmUgc3BhY2VkIG91dCBpbiB0aGlzIG9yaWVudGF0aW9uIChlLmcuIGlmIGl0J3NcclxuICAvLyAndmVydGljYWwnLCB0aGUgeS12YWx1ZXMgb2YgdGhlIGNvbXBvbmVudHMgd2lsbCBiZSBhZGp1c3RlZCB0byBzcGFjZSB0aGVtIG91dCk7IHRoaXMgaXMga25vd24gYXMgdGhlIFwicHJpbWFyeVwiXHJcbiAgLy8gYXhpcy4gSXRlbXMgd2lsbCBiZSBhbGlnbmVkL3N0cmV0Y2hlZCBpbiB0aGUgb3Bwb3NpdGUgb3JpZW50YXRpb24gKGUuZy4gaWYgaXQncyAndmVydGljYWwnLCB0aGUgeC12YWx1ZXMgb2ZcclxuICAvLyB0aGUgY29tcG9uZW50cyB3aWxsIGJlIGFkanVzdGVkIGJ5IGFsaWduIGFuZCBzdHJldGNoKTsgdGhpcyBpcyBrbm93biBhcyB0aGUgXCJzZWNvbmRhcnlcIiBvciBcIm9wcG9zaXRlXCIgYXhpcy5cclxuICAvLyBTZWUgaHR0cHM6Ly9waGV0c2ltcy5naXRodWIuaW8vc2NlbmVyeS9kb2MvbGF5b3V0I0Zsb3dCb3gtb3JpZW50YXRpb25cclxuICBvcmllbnRhdGlvbj86IExheW91dE9yaWVudGF0aW9uIHwgbnVsbDtcclxuXHJcbiAgLy8gQWRqdXN0cyB0aGUgcG9zaXRpb24gb2YgZWxlbWVudHMgaW4gdGhlIFwib3Bwb3NpdGVcIiBkaW1lbnNpb24sIGVpdGhlciB0byBhIHNwZWNpZmljIHNpZGUsIHRoZSBjZW50ZXIsIG9yIHNvIHRoYXQgYWxsXHJcbiAgLy8gdGhlIG9yaWdpbnMgb2YgaXRlbXMgYXJlIGFsaWduZWQgKHNpbWlsYXIgdG8geD0wIGZvciBhICd2ZXJ0aWNhbCcgb3JpZW50YXRpb24pLlxyXG4gIC8vIFNlZSBodHRwczovL3BoZXRzaW1zLmdpdGh1Yi5pby9zY2VuZXJ5L2RvYy9sYXlvdXQjRmxvd0JveC1hbGlnblxyXG4gIGFsaWduPzogSG9yaXpvbnRhbExheW91dEFsaWduIHwgVmVydGljYWxMYXlvdXRBbGlnbiB8IG51bGw7XHJcblxyXG4gIC8vIENvbnRyb2xzIHdoZXRoZXIgZWxlbWVudHMgd2lsbCBhdHRlbXB0IHRvIGV4cGFuZCBhbG9uZyB0aGUgXCJvcHBvc2l0ZVwiIGF4aXMgdG8gdGFrZSB1cCB0aGUgZnVsbCBzaXplIG9mIHRoZVxyXG4gIC8vIGxhcmdlc3QgbGF5b3V0IGVsZW1lbnQuXHJcbiAgLy8gU2VlIGh0dHBzOi8vcGhldHNpbXMuZ2l0aHViLmlvL3NjZW5lcnkvZG9jL2xheW91dCNGbG93Qm94LXN0cmV0Y2hcclxuICBzdHJldGNoPzogYm9vbGVhbjtcclxuXHJcbiAgLy8gQ29udHJvbHMgd2hldGhlciBlbGVtZW50cyB3aWxsIGF0dGVtcHQgdG8gZXhwYW5kIGFsb25nIHRoZSBcInByaW1hcnlcIiBheGlzLiBFbGVtZW50cyB3aWxsIGV4cGFuZCBwcm9wb3J0aW9uYWxseVxyXG4gIC8vIGJhc2VkIG9uIHRoZSB0b3RhbCBncm93IHN1bSAoYW5kIHdpbGwgbm90IGV4cGFuZCBhdCBhbGwgaWYgdGhlIGdyb3cgaXMgemVybykuXHJcbiAgLy8gU2VlIGh0dHBzOi8vcGhldHNpbXMuZ2l0aHViLmlvL3NjZW5lcnkvZG9jL2xheW91dCNGbG93Qm94LWdyb3dcclxuICBncm93PzogbnVtYmVyIHwgbnVsbDtcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIEZsb3dDb25maWd1cmFibGVPcHRpb25zID0gU2VsZk9wdGlvbnMgJiBNYXJnaW5MYXlvdXRDb25maWd1cmFibGVPcHRpb25zO1xyXG5cclxuLy8gV2UgcmVtb3ZlIHRoZSBudWxsIHZhbHVlcyBmb3IgdGhlIHZhbHVlcyB0aGF0IHdvbid0IGFjdHVhbGx5IHRha2UgbnVsbFxyXG5leHBvcnQgdHlwZSBFeHRlcm5hbEZsb3dDb25maWd1cmFibGVPcHRpb25zID0gV2l0aG91dE51bGw8Rmxvd0NvbmZpZ3VyYWJsZU9wdGlvbnMsIEV4Y2x1ZGU8a2V5b2YgRmxvd0NvbmZpZ3VyYWJsZU9wdGlvbnMsICdtaW5Db250ZW50V2lkdGgnIHwgJ21pbkNvbnRlbnRIZWlnaHQnIHwgJ21heENvbnRlbnRXaWR0aCcgfCAnbWF4Q29udGVudEhlaWdodCc+PjtcclxuXHJcbnR5cGUgVEZsb3dDb25maWd1cmFibGUgPSB7XHJcblxyXG4gIF9hbGlnbjogTGF5b3V0QWxpZ24gfCBudWxsO1xyXG4gIF9zdHJldGNoOiBib29sZWFuIHwgbnVsbDtcclxuICBfZ3JvdzogbnVtYmVyIHwgbnVsbDtcclxuICByZWFkb25seSBvcmllbnRhdGlvbkNoYW5nZWRFbWl0dGVyOiBURW1pdHRlcjtcclxuICBvcmllbnRhdGlvbjogTGF5b3V0T3JpZW50YXRpb247XHJcbiAgYWxpZ246IEhvcml6b250YWxMYXlvdXRBbGlnbiB8IFZlcnRpY2FsTGF5b3V0QWxpZ24gfCBudWxsO1xyXG4gIHN0cmV0Y2g6IGJvb2xlYW4gfCBudWxsO1xyXG4gIGdyb3c6IG51bWJlciB8IG51bGw7XHJcblxyXG4gIC8vIEBtaXhpbi1wcm90ZWN0ZWQgLSBtYWRlIHB1YmxpYyBmb3IgdXNlIGluIHRoZSBtaXhpbiBvbmx5XHJcbiAgX29yaWVudGF0aW9uOiBPcmllbnRhdGlvbjtcclxuXHJcbn0gJiBUTWFyZ2luTGF5b3V0Q29uZmlndXJhYmxlO1xyXG5cclxuLy8gKHNjZW5lcnktaW50ZXJuYWwpXHJcbmNvbnN0IEZsb3dDb25maWd1cmFibGUgPSBtZW1vaXplKCA8U3VwZXJUeXBlIGV4dGVuZHMgQ29uc3RydWN0b3I+KCBUeXBlOiBTdXBlclR5cGUgKTogU3VwZXJUeXBlICYgQ29uc3RydWN0b3I8VEZsb3dDb25maWd1cmFibGU+ID0+IHtcclxuICByZXR1cm4gY2xhc3MgRmxvd0NvbmZpZ3VyYWJsZU1peGluIGV4dGVuZHMgTWFyZ2luTGF5b3V0Q29uZmlndXJhYmxlKCBUeXBlICkgaW1wbGVtZW50cyBURmxvd0NvbmZpZ3VyYWJsZSB7XHJcblxyXG4gICAgLy8gQG1peGluLXByb3RlY3RlZCAtIG1hZGUgcHVibGljIGZvciB1c2UgaW4gdGhlIG1peGluIG9ubHlcclxuICAgIHB1YmxpYyBfb3JpZW50YXRpb246IE9yaWVudGF0aW9uID0gT3JpZW50YXRpb24uSE9SSVpPTlRBTDtcclxuXHJcbiAgICAvLyAoc2NlbmVyeS1pbnRlcm5hbClcclxuICAgIHB1YmxpYyBfYWxpZ246IExheW91dEFsaWduIHwgbnVsbCA9IG51bGw7XHJcbiAgICBwdWJsaWMgX3N0cmV0Y2g6IGJvb2xlYW4gfCBudWxsID0gbnVsbDtcclxuICAgIHB1YmxpYyBfZ3JvdzogbnVtYmVyIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgcHVibGljIHJlYWRvbmx5IG9yaWVudGF0aW9uQ2hhbmdlZEVtaXR0ZXI6IFRFbWl0dGVyID0gbmV3IFRpbnlFbWl0dGVyKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAoc2NlbmVyeS1pbnRlcm5hbClcclxuICAgICAqL1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCAuLi5hcmdzOiBJbnRlbnRpb25hbEFueVtdICkge1xyXG4gICAgICBzdXBlciggLi4uYXJncyApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogKHNjZW5lcnktaW50ZXJuYWwpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvdmVycmlkZSBtdXRhdGVDb25maWd1cmFibGUoIG9wdGlvbnM/OiBGbG93Q29uZmlndXJhYmxlT3B0aW9ucyApOiB2b2lkIHtcclxuICAgICAgc3VwZXIubXV0YXRlQ29uZmlndXJhYmxlKCBvcHRpb25zICk7XHJcblxyXG4gICAgICBtdXRhdGUoIHRoaXMsIEZMT1dfQ09ORklHVVJBQkxFX09QVElPTl9LRVlTLCBvcHRpb25zICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdmFsdWVzIHRvIHRoZSBcImJhc2VcIiBzdGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGlzIHRoZSBmYWxsYmFjayBzdGF0ZSBmb3IgYSBjb25zdHJhaW50IHdoZXJlIGV2ZXJ5IHZhbHVlIGlzIGRlZmluZWQgYW5kIHZhbGlkLiBJZiBhIGNlbGwgZG9lcyBub3QgaGF2ZSBhXHJcbiAgICAgKiBzcGVjaWZpYyBcIm92ZXJyaWRkZW5cIiB2YWx1ZSwgb3IgYSBjb25zdHJhaW50IGRvZXNuJ3QgaGF2ZSBhbiBcIm92ZXJyaWRkZW5cIiB2YWx1ZSwgdGhlbiBpdCB3aWxsIHRha2UgdGhlIHZhbHVlXHJcbiAgICAgKiBkZWZpbmVkIGhlcmUuXHJcbiAgICAgKlxyXG4gICAgICogVGhlc2Ugc2hvdWxkIGJlIHRoZSBkZWZhdWx0IHZhbHVlcyBmb3IgY29uc3RyYWludHMuXHJcbiAgICAgKlxyXG4gICAgICogKHNjZW5lcnktaW50ZXJuYWwpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvdmVycmlkZSBzZXRDb25maWdUb0Jhc2VEZWZhdWx0KCk6IHZvaWQge1xyXG4gICAgICB0aGlzLl9hbGlnbiA9IExheW91dEFsaWduLkNFTlRFUjtcclxuICAgICAgdGhpcy5fc3RyZXRjaCA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl9ncm93ID0gMDtcclxuXHJcbiAgICAgIHN1cGVyLnNldENvbmZpZ1RvQmFzZURlZmF1bHQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB2YWx1ZXMgdG8gdGhlIFwiZG9uJ3Qgb3ZlcnJpZGUgYW55dGhpbmcsIG9ubHkgaW5oZXJpdCBmcm9tIHRoZSBjb25zdHJhaW50XCIgc3RhdGVcclxuICAgICAqXHJcbiAgICAgKiBUaGVzZSBzaG91bGQgYmUgdGhlIGRlZmF1bHQgdmFsdWVzIGZvciBjZWxscyAoZS5nLiBcInRha2UgYWxsIHRoZSBiZWhhdmlvciBmcm9tIHRoZSBjb25zdHJhaW50LCBub3RoaW5nIGlzXHJcbiAgICAgKiBvdmVycmlkZGVuXCIpLlxyXG4gICAgICpcclxuICAgICAqIChzY2VuZXJ5LWludGVybmFsKVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb3ZlcnJpZGUgc2V0Q29uZmlnVG9Jbmhlcml0KCk6IHZvaWQge1xyXG4gICAgICB0aGlzLl9hbGlnbiA9IG51bGw7XHJcbiAgICAgIHRoaXMuX3N0cmV0Y2ggPSBudWxsO1xyXG4gICAgICB0aGlzLl9ncm93ID0gbnVsbDtcclxuXHJcbiAgICAgIHN1cGVyLnNldENvbmZpZ1RvSW5oZXJpdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogKHNjZW5lcnktaW50ZXJuYWwpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgb3JpZW50YXRpb24oKTogTGF5b3V0T3JpZW50YXRpb24ge1xyXG4gICAgICByZXR1cm4gdGhpcy5fb3JpZW50YXRpb24gPT09IE9yaWVudGF0aW9uLkhPUklaT05UQUwgPyAnaG9yaXpvbnRhbCcgOiAndmVydGljYWwnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogKHNjZW5lcnktaW50ZXJuYWwpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQgb3JpZW50YXRpb24oIHZhbHVlOiBMYXlvdXRPcmllbnRhdGlvbiApIHtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdmFsdWUgPT09ICdob3Jpem9udGFsJyB8fCB2YWx1ZSA9PT0gJ3ZlcnRpY2FsJyApO1xyXG5cclxuICAgICAgY29uc3QgZW51bU9yaWVudGF0aW9uID0gdmFsdWUgPT09ICdob3Jpem9udGFsJyA/IE9yaWVudGF0aW9uLkhPUklaT05UQUwgOiBPcmllbnRhdGlvbi5WRVJUSUNBTDtcclxuXHJcbiAgICAgIGlmICggdGhpcy5fb3JpZW50YXRpb24gIT09IGVudW1PcmllbnRhdGlvbiApIHtcclxuICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9IGVudW1PcmllbnRhdGlvbjtcclxuXHJcbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbkNoYW5nZWRFbWl0dGVyLmVtaXQoKTtcclxuICAgICAgICB0aGlzLmNoYW5nZWRFbWl0dGVyLmVtaXQoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogKHNjZW5lcnktaW50ZXJuYWwpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgYWxpZ24oKTogSG9yaXpvbnRhbExheW91dEFsaWduIHwgVmVydGljYWxMYXlvdXRBbGlnbiB8IG51bGwge1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBMYXlvdXRBbGlnbi5pbnRlcm5hbFRvQWxpZ24oIHRoaXMuX29yaWVudGF0aW9uLCB0aGlzLl9hbGlnbiApO1xyXG5cclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggcmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnICk7XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogKHNjZW5lcnktaW50ZXJuYWwpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXQgYWxpZ24oIHZhbHVlOiBIb3Jpem9udGFsTGF5b3V0QWxpZ24gfCBWZXJ0aWNhbExheW91dEFsaWduIHwgbnVsbCApIHtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggTGF5b3V0QWxpZ24uZ2V0QWxsb3dlZEFsaWducyggdGhpcy5fb3JpZW50YXRpb24ub3Bwb3NpdGUgKS5pbmNsdWRlcyggdmFsdWUgKSxcclxuICAgICAgICBgYWxpZ24gJHt2YWx1ZX0gbm90IHN1cHBvcnRlZCwgd2l0aCB0aGUgb3JpZW50YXRpb24gJHt0aGlzLl9vcmllbnRhdGlvbn0sIHRoZSB2YWxpZCB2YWx1ZXMgYXJlICR7TGF5b3V0QWxpZ24uZ2V0QWxsb3dlZEFsaWducyggdGhpcy5fb3JpZW50YXRpb24ub3Bwb3NpdGUgKX1gICk7XHJcblxyXG4gICAgICAvLyByZW1hcHBpbmcgYWxpZ24gdmFsdWVzIHRvIGFuIGluZGVwZW5kZW50IHNldCwgc28gdGhleSBhcmVuJ3Qgb3JpZW50YXRpb24tZGVwZW5kZW50XHJcbiAgICAgIGNvbnN0IG1hcHBlZFZhbHVlID0gTGF5b3V0QWxpZ24uYWxpZ25Ub0ludGVybmFsKCB0aGlzLl9vcmllbnRhdGlvbi5vcHBvc2l0ZSwgdmFsdWUgKTtcclxuXHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIG1hcHBlZFZhbHVlID09PSBudWxsIHx8IG1hcHBlZFZhbHVlIGluc3RhbmNlb2YgTGF5b3V0QWxpZ24gKTtcclxuXHJcbiAgICAgIGlmICggdGhpcy5fYWxpZ24gIT09IG1hcHBlZFZhbHVlICkge1xyXG4gICAgICAgIHRoaXMuX2FsaWduID0gbWFwcGVkVmFsdWU7XHJcblxyXG4gICAgICAgIHRoaXMuY2hhbmdlZEVtaXR0ZXIuZW1pdCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAoc2NlbmVyeS1pbnRlcm5hbClcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldCBzdHJldGNoKCk6IGJvb2xlYW4gfCBudWxsIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3N0cmV0Y2g7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAoc2NlbmVyeS1pbnRlcm5hbClcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCBzdHJldGNoKCB2YWx1ZTogYm9vbGVhbiB8IG51bGwgKSB7XHJcbiAgICAgIGlmICggdGhpcy5fc3RyZXRjaCAhPT0gdmFsdWUgKSB7XHJcbiAgICAgICAgdGhpcy5fc3RyZXRjaCA9IHZhbHVlO1xyXG5cclxuICAgICAgICB0aGlzLmNoYW5nZWRFbWl0dGVyLmVtaXQoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogKHNjZW5lcnktaW50ZXJuYWwpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgZ3JvdygpOiBudW1iZXIgfCBudWxsIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2dyb3c7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAoc2NlbmVyeS1pbnRlcm5hbClcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldCBncm93KCB2YWx1ZTogbnVtYmVyIHwgbnVsbCApIHtcclxuICAgICAgYXNzZXJ0ICYmIGFzc2VydCggdmFsdWUgPT09IG51bGwgfHwgKCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKCB2YWx1ZSApICYmIHZhbHVlID49IDAgKSApO1xyXG5cclxuICAgICAgaWYgKCB0aGlzLl9ncm93ICE9PSB2YWx1ZSApIHtcclxuICAgICAgICB0aGlzLl9ncm93ID0gdmFsdWU7XHJcblxyXG4gICAgICAgIHRoaXMuY2hhbmdlZEVtaXR0ZXIuZW1pdCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxufSApO1xyXG5cclxuc2NlbmVyeS5yZWdpc3RlciggJ0Zsb3dDb25maWd1cmFibGUnLCBGbG93Q29uZmlndXJhYmxlICk7XHJcbmV4cG9ydCBkZWZhdWx0IEZsb3dDb25maWd1cmFibGU7XHJcbmV4cG9ydCB7IEZMT1dfQ09ORklHVVJBQkxFX09QVElPTl9LRVlTIH07Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxXQUFXLE1BQU0sb0NBQW9DO0FBQzVELE9BQU9DLFdBQVcsTUFBTSx5Q0FBeUM7QUFDakUsT0FBT0Ms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