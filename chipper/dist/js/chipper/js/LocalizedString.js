// Copyright 2022-2024, University of Colorado Boulder

/**
 * Sets up a system of Properties to handle translation fallback and phet-io support for a single translated string.
 *
 * @author Jonathan Olson <jonathan.olson>
 */

import TinyProperty from '../../axon/js/TinyProperty.js';
import TinyOverrideProperty from '../../axon/js/TinyOverrideProperty.js';
import localeOrderProperty from '../../joist/js/i18n/localeOrderProperty.js';
import chipper from './chipper.js';
import { localizedStrings } from './getStringModule.js';
import arrayRemove from '../../phet-core/js/arrayRemove.js';
import LocalizedStringProperty from './LocalizedStringProperty.js';

// constants
const FALLBACK_LOCALE = 'en';

// for readability/docs

// Where "string" is a phetioID

class LocalizedString {
  // Public-facing IProperty<string>, used by string modules

  // Holds our non-Override Property at the root of everything

  // Uses lazy creation of locales
  localePropertyMap = new Map();
  // Store initial values, so we can handle state deltas
  initialValues = {};
  constructor(stringKey, englishValue, tandem, metadata) {
    this.stringKey = stringKey;
    this.englishProperty = new TinyProperty(englishValue);
    this.initialValues[FALLBACK_LOCALE] = englishValue;
    this.localeOrderListener = this.onLocaleOrderChange.bind(this);
    localeOrderProperty.lazyLink(this.localeOrderListener);
    this.property = new LocalizedStringProperty(this, tandem, metadata);

    // Add to a global list to support PhET-iO serialization and internal testing
    localizedStrings.push(this);
  }

  /**
   * Sets the initial value of a translated string (so that there will be no fallback for that locale/string combo)
   */
  setInitialValue(locale, value) {
    this.initialValues[locale] = value;
    this.getLocaleSpecificProperty(locale).value = value;
  }

  /**
   * Returns an object that shows the changes of strings from their initial values. This includes whether strings are
   * marked as "overridden"
   */
  getStateDelta() {
    const result = {};
    this.usedLocales.forEach(locale => {
      const rawString = this.getRawStringValue(locale);
      if (rawString !== null && rawString !== this.initialValues[locale]) {
        result[locale] = rawString;
      }
    });
    return result;
  }

  /**
   * Take a state from getStateDelta, and apply it.
   */
  setStateDelta(state) {
    // Create potential new locales (since locale-specific Properties are lazily created as needed
    Object.keys(state).forEach(locale => this.getLocaleSpecificProperty(locale));
    this.usedLocales.forEach(locale => {
      const localeSpecificProperty = this.getLocaleSpecificProperty(locale);
      const initialValue = this.initialValues[locale] !== undefined ? this.initialValues[locale] : null;
      const stateValue = state[locale] !== undefined ? state[locale] : null;

      // If not specified in the state
      if (stateValue === null) {
        // If we have no initial value, we'll want to set it to fall back
        if (initialValue === null) {
          localeSpecificProperty.clearOverride();
        } else {
          localeSpecificProperty.value = initialValue;
        }
      } else {
        localeSpecificProperty.value = stateValue;
      }
    });
  }

  /**
   * Returns the specific translation for a locale (no fallbacks), or null if that string is not translated in the
   * exact locale
   */
  getRawStringValue(locale) {
    const property = this.getLocaleSpecificProperty(locale);
    if (property instanceof TinyOverrideProperty) {
      return property.isOverridden ? property.value : null;
    } else {
      // english
      return property.value;
    }
  }
  get usedLocales() {
    // NOTE: order matters, we want the fallback to be first so that in onLocaleOrderChange we don't run into infinite
    // loops.
    return [FALLBACK_LOCALE, ...this.localePropertyMap.keys()];
  }
  onLocaleOrderChange(localeOrder) {
    // Do this in reverse order to AVOID infinite loops.
    // For example, if localeOrder1=ar,es localeOrder2=es,ar) then we could run into the case temporarily where the
    // TinyOverrideProperty for ar has its target as es, and the TinyOverrideProperty for es has its target as ar.
    // This would then trigger an infinite loop if you try to read the value of either of them, as it would ping
    // back-and-forth.
    const locales = [...this.usedLocales,
    // Yes, this duplicates some, but it should be a no-op and saves code length
    ...localeOrder];
    for (let i = locales.length - 1; i >= 0; i--) {
      const locale = locales[i];
      const localeProperty = this.getLocaleSpecificProperty(locale);
      if (localeProperty instanceof TinyOverrideProperty) {
        localeProperty.targetProperty = this.getLocaleSpecificProperty(LocalizedString.getFallbackLocale(locale));
      }
    }
  }

  /**
   * Returns the locale-specific Property for any locale (lazily creating it if necessary)
   */
  getLocaleSpecificProperty(locale) {
    if (locale === 'en') {
      return this.englishProperty;
    }

    // Lazy creation
    if (!this.localePropertyMap.has(locale)) {
      this.localePropertyMap.set(locale, new TinyOverrideProperty(this.getLocaleSpecificProperty(LocalizedString.getFallbackLocale(locale))));
    }
    return this.localePropertyMap.get(locale);
  }

  /**
   * What should be the next-most fallback locale for a given locale. Our global localeOrder is used, and otherwise it
   * defaults to our normal fallback mechanism.
   */
  static getFallbackLocale(locale) {
    if (locale === 'en') {
      return 'en'; // can be its own fallback
    }
    const localeOrder = localeOrderProperty.value;
    const index = localeOrder.indexOf(locale);
    if (index >= 0) {
      assert && assert(localeOrder[localeOrder.length - 1] === 'en');
      assert && assert(index + 1 < localeOrder.length);
      return localeOrder[index + 1];
    } else {
      // doesn't exist in those
      if (locale.includes('_')) {
        return locale.slice(0, 2); // zh_CN => zh
      } else {
        return 'en';
      }
    }
  }
  dispose() {
    localeOrderProperty.unlink(this.localeOrderListener);
    this.property.dispose();
    arrayRemove(localizedStrings, this);
  }

  /**
   * Reset to the initial value for the specified locale, used for testing.
   */
  restoreInitialValue(locale) {
    assert && assert(typeof this.initialValues[locale] === 'string', 'initial value expected for', locale);
    this.property.value = this.initialValues[locale];
  }
}
chipper.register('LocalizedString', LocalizedString);
export default LocalizedString;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJUaW55UHJvcGVydHkiLCJUaW55T3ZlcnJpZGVQcm9wZXJ0eSIsImxvY2FsZU9yZGVyUHJvcGVydHkiLCJjaGlwcGVyIiwibG9jYWxpemVkU3RyaW5ncyIsImFycmF5UmVtb3ZlIiwiTG9jYWxpemVkU3RyaW5nUHJvcGVydHkiLCJGQUxMQkFDS19MT0NBTEUiLCJMb2NhbGl6ZWRTdHJpbmciLCJsb2NhbGVQcm9wZXJ0eU1hcCIsIk1hcCIsImluaXRpYWxWYWx1ZXMiLCJjb25zdHJ1Y3RvciIsInN0cmluZ0tleSIsImVuZ2xpc2hWYWx1ZSIsInRhbmRlbSIsIm1ldGFkYXRhIiwiZW5nbGlzaFByb3BlcnR5IiwibG9jYWxlT3JkZXJMaXN0ZW5lciIsIm9uTG9jYWxlT3JkZXJDaGFuZ2UiLCJiaW5kIiwibGF6eUxpbmsiLCJwcm9wZXJ0eSIsInB1c2giLCJzZXRJbml0aWFsVmFsdWUiLCJsb2NhbGUiLCJ2YWx1ZSIsImdldExvY2FsZVNwZWNpZmljUHJvcGVydHkiLCJnZXRTdGF0ZURlbHRhIiwicmVzdWx0IiwidXNlZExvY2FsZXMiLCJmb3JFYWNoIiwicmF3U3RyaW5nIiwiZ2V0UmF3U3RyaW5nVmFsdWUiLCJzZXRTdGF0ZURlbHRhIiwic3RhdGUiLCJPYmplY3QiLCJrZXlzIiwibG9jYWxlU3BlY2lmaWNQcm9wZXJ0eSIsImluaXRpYWxWYWx1ZSIsInVuZGVmaW5lZCIsInN0YXRlVmFsdWUiLCJjbGVhck92ZXJyaWRlIiwiaXNPdmVycmlkZGVuIiwibG9jYWxlT3JkZXIiLCJsb2NhbGVzIiwiaSIsImxlbmd0aCIsImxvY2FsZVByb3BlcnR5IiwidGFyZ2V0UHJvcGVydHkiLCJnZXRGYWxsYmFja0xvY2FsZSIsImhhcyIsInNldCIsImdldCIsImluZGV4IiwiaW5kZXhPZiIsImFzc2VydCIsImluY2x1ZGVzIiwic2xpY2UiLCJkaXNwb3NlIiwidW5saW5rIiwicmVzdG9yZUluaXRpYWxWYWx1ZSIsInJlZ2lzdGVyIl0sInNvdXJjZXMiOlsiTG9jYWxpemVkU3RyaW5nLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDIyLTIwMjQsIFVuaXZlcnNpdHkgb2YgQ29sb3JhZG8gQm91bGRlclxyXG5cclxuLyoqXHJcbiAqIFNldHMgdXAgYSBzeXN0ZW0gb2YgUHJvcGVydGllcyB0byBoYW5kbGUgdHJhbnNsYXRpb24gZmFsbGJhY2sgYW5kIHBoZXQtaW8gc3VwcG9ydCBmb3IgYSBzaW5nbGUgdHJhbnNsYXRlZCBzdHJpbmcuXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9uYXRoYW4gT2xzb24gPGpvbmF0aGFuLm9sc29uPlxyXG4gKi9cclxuXHJcbmltcG9ydCBUaW55UHJvcGVydHkgZnJvbSAnLi4vLi4vYXhvbi9qcy9UaW55UHJvcGVydHkuanMnO1xyXG5pbXBvcnQgVGlueU92ZXJyaWRlUHJvcGVydHkgZnJvbSAnLi4vLi4vYXhvbi9qcy9UaW55T3ZlcnJpZGVQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCB7IExvY2FsZSB9IGZyb20gJy4uLy4uL2pvaXN0L2pzL2kxOG4vbG9jYWxlUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgbG9jYWxlT3JkZXJQcm9wZXJ0eSBmcm9tICcuLi8uLi9qb2lzdC9qcy9pMThuL2xvY2FsZU9yZGVyUHJvcGVydHkuanMnO1xyXG5pbXBvcnQgVGFuZGVtIGZyb20gJy4uLy4uL3RhbmRlbS9qcy9UYW5kZW0uanMnO1xyXG5pbXBvcnQgY2hpcHBlciBmcm9tICcuL2NoaXBwZXIuanMnO1xyXG5pbXBvcnQgVFByb3BlcnR5IGZyb20gJy4uLy4uL2F4b24vanMvVFByb3BlcnR5LmpzJztcclxuaW1wb3J0IHsgbG9jYWxpemVkU3RyaW5ncyB9IGZyb20gJy4vZ2V0U3RyaW5nTW9kdWxlLmpzJztcclxuaW1wb3J0IGFycmF5UmVtb3ZlIGZyb20gJy4uLy4uL3BoZXQtY29yZS9qcy9hcnJheVJlbW92ZS5qcyc7XHJcbmltcG9ydCB7IFBoZXRpb0lEIH0gZnJvbSAnLi4vLi4vdGFuZGVtL2pzL1RhbmRlbUNvbnN0YW50cy5qcyc7XHJcbmltcG9ydCBMb2NhbGl6ZWRTdHJpbmdQcm9wZXJ0eSBmcm9tICcuL0xvY2FsaXplZFN0cmluZ1Byb3BlcnR5LmpzJztcclxuXHJcbi8vIGNvbnN0YW50c1xyXG5jb25zdCBGQUxMQkFDS19MT0NBTEUgPSAnZW4nO1xyXG5cclxuLy8gZm9yIHJlYWRhYmlsaXR5L2RvY3NcclxudHlwZSBUcmFuc2xhdGlvblN0cmluZyA9IHN0cmluZztcclxuZXhwb3J0IHR5cGUgTG9jYWxpemVkU3RyaW5nU3RhdGVEZWx0YSA9IFBhcnRpYWw8UmVjb3JkPExvY2FsZSwgVHJhbnNsYXRpb25TdHJpbmc+PjtcclxuXHJcbi8vIFdoZXJlIFwic3RyaW5nXCIgaXMgYSBwaGV0aW9JRFxyXG5leHBvcnQgdHlwZSBTdHJpbmdzU3RhdGVTdGF0ZU9iamVjdCA9IHsgZGF0YTogUmVjb3JkPFBoZXRpb0lELCBMb2NhbGl6ZWRTdHJpbmdTdGF0ZURlbHRhPiB9O1xyXG5cclxuY2xhc3MgTG9jYWxpemVkU3RyaW5nIHtcclxuXHJcbiAgLy8gUHVibGljLWZhY2luZyBJUHJvcGVydHk8c3RyaW5nPiwgdXNlZCBieSBzdHJpbmcgbW9kdWxlc1xyXG4gIHB1YmxpYyByZWFkb25seSBwcm9wZXJ0eTogTG9jYWxpemVkU3RyaW5nUHJvcGVydHk7XHJcblxyXG4gIC8vIEhvbGRzIG91ciBub24tT3ZlcnJpZGUgUHJvcGVydHkgYXQgdGhlIHJvb3Qgb2YgZXZlcnl0aGluZ1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgZW5nbGlzaFByb3BlcnR5OiBUaW55UHJvcGVydHk8VHJhbnNsYXRpb25TdHJpbmc+O1xyXG5cclxuICAvLyBVc2VzIGxhenkgY3JlYXRpb24gb2YgbG9jYWxlc1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgbG9jYWxlUHJvcGVydHlNYXAgPSBuZXcgTWFwPExvY2FsZSwgVGlueU92ZXJyaWRlUHJvcGVydHk8VHJhbnNsYXRpb25TdHJpbmc+PigpO1xyXG5cclxuICBwcml2YXRlIHJlYWRvbmx5IGxvY2FsZU9yZGVyTGlzdGVuZXI6ICggbG9jYWxlczogTG9jYWxlW10gKSA9PiB2b2lkO1xyXG5cclxuICAvLyBTdG9yZSBpbml0aWFsIHZhbHVlcywgc28gd2UgY2FuIGhhbmRsZSBzdGF0ZSBkZWx0YXNcclxuICBwcml2YXRlIHJlYWRvbmx5IGluaXRpYWxWYWx1ZXM6IExvY2FsaXplZFN0cmluZ1N0YXRlRGVsdGEgPSB7fTtcclxuXHJcbiAgcHVibGljIGNvbnN0cnVjdG9yKCBwdWJsaWMgcmVhZG9ubHkgc3RyaW5nS2V5OiBzdHJpbmcsIGVuZ2xpc2hWYWx1ZTogVHJhbnNsYXRpb25TdHJpbmcsIHRhbmRlbTogVGFuZGVtLCBtZXRhZGF0YT86IFJlY29yZDxzdHJpbmcsIHVua25vd24+ICkge1xyXG5cclxuICAgIHRoaXMuZW5nbGlzaFByb3BlcnR5ID0gbmV3IFRpbnlQcm9wZXJ0eSggZW5nbGlzaFZhbHVlICk7XHJcbiAgICB0aGlzLmluaXRpYWxWYWx1ZXNbIEZBTExCQUNLX0xPQ0FMRSBdID0gZW5nbGlzaFZhbHVlO1xyXG5cclxuICAgIHRoaXMubG9jYWxlT3JkZXJMaXN0ZW5lciA9IHRoaXMub25Mb2NhbGVPcmRlckNoYW5nZS5iaW5kKCB0aGlzICk7XHJcbiAgICBsb2NhbGVPcmRlclByb3BlcnR5LmxhenlMaW5rKCB0aGlzLmxvY2FsZU9yZGVyTGlzdGVuZXIgKTtcclxuXHJcbiAgICB0aGlzLnByb3BlcnR5ID0gbmV3IExvY2FsaXplZFN0cmluZ1Byb3BlcnR5KCB0aGlzLCB0YW5kZW0sIG1ldGFkYXRhICk7XHJcblxyXG4gICAgLy8gQWRkIHRvIGEgZ2xvYmFsIGxpc3QgdG8gc3VwcG9ydCBQaEVULWlPIHNlcmlhbGl6YXRpb24gYW5kIGludGVybmFsIHRlc3RpbmdcclxuICAgIGxvY2FsaXplZFN0cmluZ3MucHVzaCggdGhpcyApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiBhIHRyYW5zbGF0ZWQgc3RyaW5nIChzbyB0aGF0IHRoZXJlIHdpbGwgYmUgbm8gZmFsbGJhY2sgZm9yIHRoYXQgbG9jYWxlL3N0cmluZyBjb21ibylcclxuICAgKi9cclxuICBwdWJsaWMgc2V0SW5pdGlhbFZhbHVlKCBsb2NhbGU6IExvY2FsZSwgdmFsdWU6IFRyYW5zbGF0aW9uU3RyaW5nICk6IHZvaWQge1xyXG4gICAgdGhpcy5pbml0aWFsVmFsdWVzWyBsb2NhbGUgXSA9IHZhbHVlO1xyXG4gICAgdGhpcy5nZXRMb2NhbGVTcGVjaWZpY1Byb3BlcnR5KCBsb2NhbGUgKS52YWx1ZSA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBzaG93cyB0aGUgY2hhbmdlcyBvZiBzdHJpbmdzIGZyb20gdGhlaXIgaW5pdGlhbCB2YWx1ZXMuIFRoaXMgaW5jbHVkZXMgd2hldGhlciBzdHJpbmdzIGFyZVxyXG4gICAqIG1hcmtlZCBhcyBcIm92ZXJyaWRkZW5cIlxyXG4gICAqL1xyXG4gIHB1YmxpYyBnZXRTdGF0ZURlbHRhKCk6IExvY2FsaXplZFN0cmluZ1N0YXRlRGVsdGEge1xyXG4gICAgY29uc3QgcmVzdWx0OiBMb2NhbGl6ZWRTdHJpbmdTdGF0ZURlbHRhID0ge307XHJcblxyXG4gICAgdGhpcy51c2VkTG9jYWxlcy5mb3JFYWNoKCBsb2NhbGUgPT4ge1xyXG4gICAgICBjb25zdCByYXdTdHJpbmcgPSB0aGlzLmdldFJhd1N0cmluZ1ZhbHVlKCBsb2NhbGUgKTtcclxuICAgICAgaWYgKCByYXdTdHJpbmcgIT09IG51bGwgJiYgcmF3U3RyaW5nICE9PSB0aGlzLmluaXRpYWxWYWx1ZXNbIGxvY2FsZSBdICkge1xyXG4gICAgICAgIHJlc3VsdFsgbG9jYWxlIF0gPSByYXdTdHJpbmc7XHJcbiAgICAgIH1cclxuICAgIH0gKTtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGFrZSBhIHN0YXRlIGZyb20gZ2V0U3RhdGVEZWx0YSwgYW5kIGFwcGx5IGl0LlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzZXRTdGF0ZURlbHRhKCBzdGF0ZTogTG9jYWxpemVkU3RyaW5nU3RhdGVEZWx0YSApOiB2b2lkIHtcclxuXHJcbiAgICAvLyBDcmVhdGUgcG90ZW50aWFsIG5ldyBsb2NhbGVzIChzaW5jZSBsb2NhbGUtc3BlY2lmaWMgUHJvcGVydGllcyBhcmUgbGF6aWx5IGNyZWF0ZWQgYXMgbmVlZGVkXHJcbiAgICBPYmplY3Qua2V5cyggc3RhdGUgKS5mb3JFYWNoKCBsb2NhbGUgPT4gdGhpcy5nZXRMb2NhbGVTcGVjaWZpY1Byb3BlcnR5KCBsb2NhbGUgYXMgTG9jYWxlICkgKTtcclxuXHJcbiAgICB0aGlzLnVzZWRMb2NhbGVzLmZvckVhY2goIGxvY2FsZSA9PiB7XHJcbiAgICAgIGNvbnN0IGxvY2FsZVNwZWNpZmljUHJvcGVydHkgPSB0aGlzLmdldExvY2FsZVNwZWNpZmljUHJvcGVydHkoIGxvY2FsZSApO1xyXG4gICAgICBjb25zdCBpbml0aWFsVmFsdWU6IHN0cmluZyB8IG51bGwgPSB0aGlzLmluaXRpYWxWYWx1ZXNbIGxvY2FsZSBdICE9PSB1bmRlZmluZWQgPyB0aGlzLmluaXRpYWxWYWx1ZXNbIGxvY2FsZSBdISA6IG51bGw7XHJcbiAgICAgIGNvbnN0IHN0YXRlVmFsdWU6IHN0cmluZyB8IG51bGwgPSBzdGF0ZVsgbG9jYWxlIF0gIT09IHVuZGVmaW5lZCA/IHN0YXRlWyBsb2NhbGUgXSEgOiBudWxsO1xyXG5cclxuICAgICAgLy8gSWYgbm90IHNwZWNpZmllZCBpbiB0aGUgc3RhdGVcclxuICAgICAgaWYgKCBzdGF0ZVZhbHVlID09PSBudWxsICkge1xyXG5cclxuICAgICAgICAvLyBJZiB3ZSBoYXZlIG5vIGluaXRpYWwgdmFsdWUsIHdlJ2xsIHdhbnQgdG8gc2V0IGl0IHRvIGZhbGwgYmFja1xyXG4gICAgICAgIGlmICggaW5pdGlhbFZhbHVlID09PSBudWxsICkge1xyXG4gICAgICAgICAgKCBsb2NhbGVTcGVjaWZpY1Byb3BlcnR5IGFzIFRpbnlPdmVycmlkZVByb3BlcnR5PHN0cmluZz4gKS5jbGVhck92ZXJyaWRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgbG9jYWxlU3BlY2lmaWNQcm9wZXJ0eS52YWx1ZSA9IGluaXRpYWxWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgbG9jYWxlU3BlY2lmaWNQcm9wZXJ0eS52YWx1ZSA9IHN0YXRlVmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH0gKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHNwZWNpZmljIHRyYW5zbGF0aW9uIGZvciBhIGxvY2FsZSAobm8gZmFsbGJhY2tzKSwgb3IgbnVsbCBpZiB0aGF0IHN0cmluZyBpcyBub3QgdHJhbnNsYXRlZCBpbiB0aGVcclxuICAgKiBleGFjdCBsb2NhbGVcclxuICAgKi9cclxuICBwcml2YXRlIGdldFJhd1N0cmluZ1ZhbHVlKCBsb2NhbGU6IExvY2FsZSApOiBzdHJpbmcgfCBudWxsIHtcclxuICAgIGNvbnN0IHByb3BlcnR5ID0gdGhpcy5nZXRMb2NhbGVTcGVjaWZpY1Byb3BlcnR5KCBsb2NhbGUgKTtcclxuICAgIGlmICggcHJvcGVydHkgaW5zdGFuY2VvZiBUaW55T3ZlcnJpZGVQcm9wZXJ0eSApIHtcclxuICAgICAgcmV0dXJuIHByb3BlcnR5LmlzT3ZlcnJpZGRlbiA/IHByb3BlcnR5LnZhbHVlIDogbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAvLyBlbmdsaXNoXHJcbiAgICAgIHJldHVybiBwcm9wZXJ0eS52YWx1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2V0IHVzZWRMb2NhbGVzKCk6IExvY2FsZVtdIHtcclxuICAgIC8vIE5PVEU6IG9yZGVyIG1hdHRlcnMsIHdlIHdhbnQgdGhlIGZhbGxiYWNrIHRvIGJlIGZpcnN0IHNvIHRoYXQgaW4gb25Mb2NhbGVPcmRlckNoYW5nZSB3ZSBkb24ndCBydW4gaW50byBpbmZpbml0ZVxyXG4gICAgLy8gbG9vcHMuXHJcbiAgICByZXR1cm4gWyBGQUxMQkFDS19MT0NBTEUsIC4uLnRoaXMubG9jYWxlUHJvcGVydHlNYXAua2V5cygpIF07XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIG9uTG9jYWxlT3JkZXJDaGFuZ2UoIGxvY2FsZU9yZGVyOiBMb2NhbGVbXSApOiB2b2lkIHtcclxuXHJcbiAgICAvLyBEbyB0aGlzIGluIHJldmVyc2Ugb3JkZXIgdG8gQVZPSUQgaW5maW5pdGUgbG9vcHMuXHJcbiAgICAvLyBGb3IgZXhhbXBsZSwgaWYgbG9jYWxlT3JkZXIxPWFyLGVzIGxvY2FsZU9yZGVyMj1lcyxhcikgdGhlbiB3ZSBjb3VsZCBydW4gaW50byB0aGUgY2FzZSB0ZW1wb3JhcmlseSB3aGVyZSB0aGVcclxuICAgIC8vIFRpbnlPdmVycmlkZVByb3BlcnR5IGZvciBhciBoYXMgaXRzIHRhcmdldCBhcyBlcywgYW5kIHRoZSBUaW55T3ZlcnJpZGVQcm9wZXJ0eSBmb3IgZXMgaGFzIGl0cyB0YXJnZXQgYXMgYXIuXHJcbiAgICAvLyBUaGlzIHdvdWxkIHRoZW4gdHJpZ2dlciBhbiBpbmZpbml0ZSBsb29wIGlmIHlvdSB0cnkgdG8gcmVhZCB0aGUgdmFsdWUgb2YgZWl0aGVyIG9mIHRoZW0sIGFzIGl0IHdvdWxkIHBpbmdcclxuICAgIC8vIGJhY2stYW5kLWZvcnRoLlxyXG4gICAgY29uc3QgbG9jYWxlczogTG9jYWxlW10gPSBbXHJcbiAgICAgIC4uLnRoaXMudXNlZExvY2FsZXMsXHJcblxyXG4gICAgICAvLyBZZXMsIHRoaXMgZHVwbGljYXRlcyBzb21lLCBidXQgaXQgc2hvdWxkIGJlIGEgbm8tb3AgYW5kIHNhdmVzIGNvZGUgbGVuZ3RoXHJcbiAgICAgIC4uLmxvY2FsZU9yZGVyXHJcbiAgICBdO1xyXG4gICAgZm9yICggbGV0IGkgPSBsb2NhbGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICkge1xyXG4gICAgICBjb25zdCBsb2NhbGUgPSBsb2NhbGVzWyBpIF07XHJcbiAgICAgIGNvbnN0IGxvY2FsZVByb3BlcnR5ID0gdGhpcy5nZXRMb2NhbGVTcGVjaWZpY1Byb3BlcnR5KCBsb2NhbGUgKTtcclxuICAgICAgaWYgKCBsb2NhbGVQcm9wZXJ0eSBpbnN0YW5jZW9mIFRpbnlPdmVycmlkZVByb3BlcnR5ICkge1xyXG4gICAgICAgIGxvY2FsZVByb3BlcnR5LnRhcmdldFByb3BlcnR5ID0gdGhpcy5nZXRMb2NhbGVTcGVjaWZpY1Byb3BlcnR5KCBMb2NhbGl6ZWRTdHJpbmcuZ2V0RmFsbGJhY2tMb2NhbGUoIGxvY2FsZSApICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGxvY2FsZS1zcGVjaWZpYyBQcm9wZXJ0eSBmb3IgYW55IGxvY2FsZSAobGF6aWx5IGNyZWF0aW5nIGl0IGlmIG5lY2Vzc2FyeSlcclxuICAgKi9cclxuICBwdWJsaWMgZ2V0TG9jYWxlU3BlY2lmaWNQcm9wZXJ0eSggbG9jYWxlOiBMb2NhbGUgKTogVFByb3BlcnR5PHN0cmluZz4ge1xyXG4gICAgaWYgKCBsb2NhbGUgPT09ICdlbicgKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmVuZ2xpc2hQcm9wZXJ0eTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBMYXp5IGNyZWF0aW9uXHJcbiAgICBpZiAoICF0aGlzLmxvY2FsZVByb3BlcnR5TWFwLmhhcyggbG9jYWxlICkgKSB7XHJcbiAgICAgIHRoaXMubG9jYWxlUHJvcGVydHlNYXAuc2V0KCBsb2NhbGUsIG5ldyBUaW55T3ZlcnJpZGVQcm9wZXJ0eSggdGhpcy5nZXRMb2NhbGVTcGVjaWZpY1Byb3BlcnR5KCBMb2NhbGl6ZWRTdHJpbmcuZ2V0RmFsbGJhY2tMb2NhbGUoIGxvY2FsZSApICkgKSApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLmxvY2FsZVByb3BlcnR5TWFwLmdldCggbG9jYWxlICkhO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogV2hhdCBzaG91bGQgYmUgdGhlIG5leHQtbW9zdCBmYWxsYmFjayBsb2NhbGUgZm9yIGEgZ2l2ZW4gbG9jYWxlLiBPdXIgZ2xvYmFsIGxvY2FsZU9yZGVyIGlzIHVzZWQsIGFuZCBvdGhlcndpc2UgaXRcclxuICAgKiBkZWZhdWx0cyB0byBvdXIgbm9ybWFsIGZhbGxiYWNrIG1lY2hhbmlzbS5cclxuICAgKi9cclxuICBwdWJsaWMgc3RhdGljIGdldEZhbGxiYWNrTG9jYWxlKCBsb2NhbGU6IExvY2FsZSApOiBMb2NhbGUge1xyXG4gICAgaWYgKCBsb2NhbGUgPT09ICdlbicgKSB7XHJcbiAgICAgIHJldHVybiAnZW4nOyAvLyBjYW4gYmUgaXRzIG93biBmYWxsYmFja1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGxvY2FsZU9yZGVyID0gbG9jYWxlT3JkZXJQcm9wZXJ0eS52YWx1ZTtcclxuXHJcbiAgICBjb25zdCBpbmRleCA9IGxvY2FsZU9yZGVyLmluZGV4T2YoIGxvY2FsZSApO1xyXG4gICAgaWYgKCBpbmRleCA+PSAwICkge1xyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCBsb2NhbGVPcmRlclsgbG9jYWxlT3JkZXIubGVuZ3RoIC0gMSBdID09PSAnZW4nICk7XHJcbiAgICAgIGFzc2VydCAmJiBhc3NlcnQoIGluZGV4ICsgMSA8IGxvY2FsZU9yZGVyLmxlbmd0aCApO1xyXG4gICAgICByZXR1cm4gbG9jYWxlT3JkZXJbIGluZGV4ICsgMSBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIC8vIGRvZXNuJ3QgZXhpc3QgaW4gdGhvc2VcclxuICAgICAgaWYgKCBsb2NhbGUuaW5jbHVkZXMoICdfJyApICkge1xyXG4gICAgICAgIHJldHVybiBsb2NhbGUuc2xpY2UoIDAsIDIgKSBhcyBMb2NhbGU7IC8vIHpoX0NOID0+IHpoXHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuICdlbic7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHB1YmxpYyBkaXNwb3NlKCk6IHZvaWQge1xyXG4gICAgbG9jYWxlT3JkZXJQcm9wZXJ0eS51bmxpbmsoIHRoaXMubG9jYWxlT3JkZXJMaXN0ZW5lciApO1xyXG5cclxuICAgIHRoaXMucHJvcGVydHkuZGlzcG9zZSgpO1xyXG4gICAgYXJyYXlSZW1vdmUoIGxvY2FsaXplZFN0cmluZ3MsIHRoaXMgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2V0IHRvIHRoZSBpbml0aWFsIHZhbHVlIGZvciB0aGUgc3BlY2lmaWVkIGxvY2FsZSwgdXNlZCBmb3IgdGVzdGluZy5cclxuICAgKi9cclxuICBwdWJsaWMgcmVzdG9yZUluaXRpYWxWYWx1ZSggbG9jYWxlOiBMb2NhbGUgKTogdm9pZCB7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0eXBlb2YgdGhpcy5pbml0aWFsVmFsdWVzWyBsb2NhbGUgXSA9PT0gJ3N0cmluZycsICdpbml0aWFsIHZhbHVlIGV4cGVjdGVkIGZvcicsIGxvY2FsZSApO1xyXG4gICAgdGhpcy5wcm9wZXJ0eS52YWx1ZSA9IHRoaXMuaW5pdGlhbFZhbHVlc1sgbG9jYWxlIF0hO1xyXG4gIH1cclxufVxyXG5cclxuY2hpcHBlci5yZWdpc3RlciggJ0xvY2FsaXplZFN0cmluZycsIExvY2FsaXplZFN0cmluZyApO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTG9jYWxpemVkU3RyaW5nOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxZQUFZLE1BQU0sK0JBQStCO0FBQ3hELE9BQU9DLG9CQUFvQixNQUFNLHVDQUF1QztBQUV4RSxPQUFPQyxtQkFBbUIsTUFBTSw0Q0FBNEM7QUFFNUUsT0FBT0MsT0FBTyxNQUFNLGNBQWM7QUFFbEMsU0FBU0MsZ0JBQWdCLFFBQVEsc0JBQXNCO0FBQ3ZELE9BQU9DLFdBQVcsTUFBTSxtQ0FBbUM7QUFFM0QsT0FBT0MsdUJBQXVCLE1BQU0sOEJBQThCOztBQUVsRTtBQUNBLE1BQU1DLGVBQWUsR0FBRyxJ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