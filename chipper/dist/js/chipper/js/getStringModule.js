// Copyright 2020-2024, University of Colorado Boulder

/**
 * Given a requirejsNamespace, we filter out strings from phet.chipper.strings that start with it, and construct an
 * object with locale fallbacks already pre-computed, so that the correct strings can be accessed via object literal
 * access, e.g. getStringModule( 'JOIST' ).ResetAllButton.name will give the desired string value for whatever locale
 * the sim is being run with.
 *
 * A string "key" is in the form of "NAMESPACE/key.from.strings.json"
 *
 * NOTE: This file likely belongs in joist/js/i18n/, but should stay here to make maintenance-release maintainability easier.
 *
 * @author Jonathan Olson <jonathan.olson>
 */

import PhetioObject from '../../tandem/js/PhetioObject.js';
import Tandem from '../../tandem/js/Tandem.js';
import CouldNotYetDeserializeError from '../../tandem/js/CouldNotYetDeserializeError.js';
import IOType from '../../tandem/js/types/IOType.js';
import ObjectLiteralIO from '../../tandem/js/types/ObjectLiteralIO.js';
import LocalizedString from './LocalizedString.js';
import localeInfoModule from '../../chipper/js/data/localeInfoModule.js';
// constants
const FALLBACK_LOCALE = 'en';

// Holds all of our localizedStrings, so that we can save our phet-io string change state
export const localizedStrings = [];

// For developer internal use, particularly for memory leak detection
// e.g. _.max( phet.chipper.localizedStrings.map( ls => ls.property.tinyProperty.listeners.size ) ) to see if there is
// likely a leak
window.phet.chipper.localizedStrings = localizedStrings;

// For developer internal use, similar to the stringTest query parameter
window.phet.chipper.setAllStrings = str => {
  localizedStrings.forEach(localizedString => {
    localizedString.property.value = str;
  });
};
const stringKeyToTandemName = key => {
  return key.replace(/(?:[-_\s]\w)/g, word => word[1].toUpperCase());
};
const StringStateIOType = new IOType('StringStateIO', {
  valueType: PhetioObject,
  toStateObject: () => {
    const data = {};
    localizedStrings.forEach(localizedString => {
      const state = localizedString.getStateDelta();

      // Only create an entry if there is anything (we can save bytes by not including the tandem here)
      if (Object.keys(state).length > 0) {
        data[localizedString.property.tandem.phetioID] = state;
      }
    });
    return {
      data: data // Data nested for a valid schema
    };
  },
  stateSchema: {
    data: ObjectLiteralIO
  },
  applyState: (ignored, state) => {
    // Every string in state has to be in localizedStrings to continue
    Object.keys(state.data).forEach(phetioID => {
      const match = localizedStrings.find(localizedString => localizedString.property.tandem.phetioID === phetioID);

      // When PhetioDynamicElementContainer elements such as PhetioGroup members add localizedStrings, we wait until
      // all of the members have been created (populating localizedStrings) before trying to set any of the strings.
      if (!match) {
        throw new CouldNotYetDeserializeError();
      }
    });

    // We need to iterate through every string in this runtime, since it might need to revert back to "initial" state.
    localizedStrings.forEach(localizedString => {
      localizedString.setStateDelta(state.data[localizedString.property.tandem.phetioID] || {});
    });
  }
});
PhetioObject.create({
  phetioType: StringStateIOType,
  tandem: Tandem.GENERAL_MODEL.createTandem('stringsState'),
  phetioDocumentation: 'Strings that have changed from their initial values. Each string value is specific to the locale it changed in.',
  phetioState: true
});
/**
 * @param requirejsNamespace - E.g. 'JOIST', to pull string keys out from that namespace
 * @returns Nested object to be accessed like JoistStrings.ResetAllButton.name
 */
const getStringModule = requirejsNamespace => {
  // Our string information is pulled globally, e.g. phet.chipper.strings[ locale ][ stringKey ] = stringValue;
  // Our locale information is from phet.chipper.locale

  assert && assert(typeof phet.chipper.locale === 'string', 'phet.chipper.locale should have been loaded by now');
  assert && assert(Object.keys(localeInfoModule).includes(phet.chipper.locale), 'phet.chipper.locale should have been loaded by now');
  assert && assert(phet.chipper.strings, 'phet.chipper.strings should have been loaded by now');

  // Construct locales in increasing specificity, e.g. [ 'en', 'zh', 'zh_CN' ], so we get fallbacks in order
  // const locales = [ FALLBACK_LOCALE ];
  const stringKeyPrefix = `${requirejsNamespace}/`;

  // We may have other older (unused) keys in babel, and we are only doing the search that matters with the English
  // string keys.
  let allStringKeysInRepo = Object.keys(phet.chipper.strings[FALLBACK_LOCALE]).filter(stringKey => stringKey.startsWith(stringKeyPrefix));

  // TODO: https://github.com/phetsims/phet-io/issues/1877 What if this list doesn't exist?  Should that be an error?
  // Or an error if running an api-stable phet-io sim?
  // TODO: https://github.com/phetsims/phet-io/issues/1877 What will happen if this is stale? How will a developer know
  // to update it? Should it run in daily-grunt-work?
  if (phet.chipper.usedStringsEN) {
    allStringKeysInRepo = allStringKeysInRepo.filter(stringKey => phet.chipper.usedStringsEN.hasOwnProperty(stringKey));
  }

  // localizedStringMap[ stringKey ]
  const localizedStringMap = {};
  const stringModule = {};
  allStringKeysInRepo.forEach(stringKey => {
    // strip off the requirejsNamespace, e.g. 'JOIST/ResetAllButton.name' => 'ResetAllButton.name'
    const stringKeyWithoutPrefix = stringKey.slice(stringKeyPrefix.length);
    const keyParts = stringKeyWithoutPrefix.split('.');
    const lastKeyPart = keyParts[keyParts.length - 1];
    const allButLastKeyPart = keyParts.slice(0, keyParts.length - 1);

    // During traversal into the string object, this will hold the object where the next level needs to be defined,
    // whether that's another child object, or the string value itself.
    let reference = stringModule;

    // We'll traverse down through the parts of a string key (separated by '.'), creating a new level in the
    // string object for each one. This is done for all BUT the last part, since we'll want to assign the result
    // of that to a raw string value (rather than an object).
    let partialKey = stringKeyPrefix;
    allButLastKeyPart.forEach((keyPart, i) => {
      // When concatenating each level into the final string key, we don't want to put a '.' directly after the
      // slash, because `JOIST/.ResetAllButton.name` would be invalid.
      // See https://github.com/phetsims/chipper/issues/922
      partialKey += `${i > 0 ? '.' : ''}${keyPart}`;

      // Don't allow e.g. JOIST/a and JOIST/a.b, since localeObject.a would need to be a string AND an object at the
      // same time.
      assert && assert(typeof reference[keyPart] !== 'string', 'It is not allowed to have two different string keys where one is extended by adding a period (.) at the end ' + `of the other. The string key ${partialKey} is extended by ${stringKey} in this case, and should be changed.`);

      // Create the next nested level, and move into it
      if (!reference[keyPart]) {
        reference[keyPart] = {};
      }
      reference = reference[keyPart]; // since we are on all but the last key part, it cannot be stringlike
    });
    assert && assert(typeof reference[lastKeyPart] !== 'object', 'It is not allowed to have two different string keys where one is extended by adding a period (.) at the end ' + `of the other. The string key ${stringKey} is extended by another key, something containing ${reference[lastKeyPart] && Object.keys(reference[lastKeyPart])}.`);
    assert && assert(!reference[lastKeyPart], `We should not have defined this place in the object (${stringKey}), otherwise it means a duplicated string key OR extended string key`);

    // In case our assertions are not enabled, we'll need to proceed without failing out (so we allow for the
    // extended string keys in our actual code, even though assertions should prevent that).
    if (typeof reference !== 'string') {
      let tandem = Tandem.STRINGS.createTandem(_.camelCase(requirejsNamespace));
      for (let i = 0; i < keyParts.length; i++) {
        let tandemName = stringKeyToTandemName(keyParts[i]);

        // If it is the tail of the string key, then make the tandem be a "*StringProperty"
        if (i === keyParts.length - 1) {
          let currentTandemName = tandemName;
          let j = 0;
          let tandemNameTaken = true;

          // Handle the case where two unique string keys map to the same camel case value, i.e. "Solid" and "solid".
          // Here we will be solidStringProperty and solid2StringProperty
          while (tandemNameTaken) {
            j++;
            currentTandemName = `${tandemName}${j === 1 ? '' : j}StringProperty`;
            tandemNameTaken = tandem.hasChild(currentTandemName);
          }
          tandemName = currentTandemName;
        }
        tandem = tandem.createTandem(tandemName);
      }

      // strings nested under the a11y section are not currently PhET-iO instrumented, see https://github.com/phetsims/chipper/issues/1352
      if (tandem.phetioID.includes('.a11y.')) {
        tandem = Tandem.OPT_OUT;
      }
      const localizedString = new LocalizedString(stringKey, phet.chipper.mapString(phet.chipper.strings[FALLBACK_LOCALE][stringKey]), tandem, phet.chipper.stringMetadata[stringKey]);
      localizedStringMap[stringKey] = localizedString;

      // Push up the translated values
      Object.keys(phet.chipper.strings).forEach(locale => {
        const string = phet.chipper.strings[locale][stringKey];
        // Ignore zero-length strings, see https://github.com/phetsims/chipper/issues/1343
        if (typeof string === 'string' && string !== '') {
          localizedString.setInitialValue(locale, phet.chipper.mapString(string));
        }
      });

      // Put our Property in the stringModule
      reference[`${lastKeyPart}StringProperty`] = localizedString.property;

      // Change our stringModule based on the Property value
      localizedString.property.link(string => {
        reference[lastKeyPart] = string;
      });
    }
  });
  return stringModule;
};
export default getStringModule;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJQaGV0aW9PYmplY3QiLCJUYW5kZW0iLCJDb3VsZE5vdFlldERlc2VyaWFsaXplRXJyb3IiLCJJT1R5cGUiLCJPYmplY3RMaXRlcmFsSU8iLCJMb2NhbGl6ZWRTdHJpbmciLCJsb2NhbGVJbmZvTW9kdWxlIiwiRkFMTEJBQ0tfTE9DQUxFIiwibG9jYWxpemVkU3RyaW5ncyIsIndpbmRvdyIsInBoZXQiLCJjaGlwcGVyIiwic2V0QWxsU3RyaW5ncyIsInN0ciIsImZvckVhY2giLCJsb2NhbGl6ZWRTdHJpbmciLCJwcm9wZXJ0eSIsInZhbHVlIiwic3RyaW5nS2V5VG9UYW5kZW1OYW1lIiwia2V5IiwicmVwbGFjZSIsIndvcmQiLCJ0b1VwcGVyQ2FzZSIsIlN0cmluZ1N0YXRlSU9UeXBlIiwidmFsdWVUeXBlIiwidG9TdGF0ZU9iamVjdCIsImRhdGEiLCJzdGF0ZSIsImdldFN0YXRlRGVsdGEiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwidGFuZGVtIiwicGhldGlvSUQiLCJzdGF0ZVNjaGVtYSIsImFwcGx5U3RhdGUiLCJpZ25vcmVkIiwibWF0Y2giLCJmaW5kIiwic2V0U3RhdGVEZWx0YSIsImNyZWF0ZSIsInBoZXRpb1R5cGUiLCJHRU5FUkFMX01PREVMIiwiY3JlYXRlVGFuZGVtIiwicGhldGlvRG9jdW1lbnRhdGlvbiIsInBoZXRpb1N0YXRlIiwiZ2V0U3RyaW5nTW9kdWxlIiwicmVxdWlyZWpzTmFtZXNwYWNlIiwiYXNzZXJ0IiwibG9jYWxlIiwiaW5jbHVkZXMiLCJzdHJpbmdzIiwic3RyaW5nS2V5UHJlZml4IiwiYWxsU3RyaW5nS2V5c0luUmVwbyIsImZpbHRlciIsInN0cmluZ0tleSIsInN0YXJ0c1dpdGgiLCJ1c2VkU3RyaW5nc0VOIiwiaGFzT3duUHJvcGVydHkiLCJsb2NhbGl6ZWRTdHJpbmdNYXAiLCJzdHJpbmdNb2R1bGUiLCJzdHJpbmdLZXlXaXRob3V0UHJlZml4Iiwic2xpY2UiLCJrZXlQYXJ0cyIsInNwbGl0IiwibGFzdEtleVBhcnQiLCJhbGxCdXRMYXN0S2V5UGFydCIsInJlZmVyZW5jZSIsInBhcnRpYWxLZXkiLCJrZXlQYXJ0IiwiaSIsIlNUUklOR1MiLCJfIiwiY2FtZWxDYXNlIiwidGFuZGVtTmFtZSIsImN1cnJlbnRUYW5kZW1OYW1lIiwiaiIsInRhbmRlbU5hbWVUYWtlbiIsImhhc0NoaWxkIiwiT1BUX09VVCIsIm1hcFN0cmluZyIsInN0cmluZ01ldGFkYXRhIiwic3RyaW5nIiwic2V0SW5pdGlhbFZhbHVlIiwibGluayJdLCJzb3VyY2VzIjpbImdldFN0cmluZ01vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAyMC0yMDI0LCBVbml2ZXJzaXR5IG9mIENvbG9yYWRvIEJvdWxkZXJcclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhIHJlcXVpcmVqc05hbWVzcGFjZSwgd2UgZmlsdGVyIG91dCBzdHJpbmdzIGZyb20gcGhldC5jaGlwcGVyLnN0cmluZ3MgdGhhdCBzdGFydCB3aXRoIGl0LCBhbmQgY29uc3RydWN0IGFuXHJcbiAqIG9iamVjdCB3aXRoIGxvY2FsZSBmYWxsYmFja3MgYWxyZWFkeSBwcmUtY29tcHV0ZWQsIHNvIHRoYXQgdGhlIGNvcnJlY3Qgc3RyaW5ncyBjYW4gYmUgYWNjZXNzZWQgdmlhIG9iamVjdCBsaXRlcmFsXHJcbiAqIGFjY2VzcywgZS5nLiBnZXRTdHJpbmdNb2R1bGUoICdKT0lTVCcgKS5SZXNldEFsbEJ1dHRvbi5uYW1lIHdpbGwgZ2l2ZSB0aGUgZGVzaXJlZCBzdHJpbmcgdmFsdWUgZm9yIHdoYXRldmVyIGxvY2FsZVxyXG4gKiB0aGUgc2ltIGlzIGJlaW5nIHJ1biB3aXRoLlxyXG4gKlxyXG4gKiBBIHN0cmluZyBcImtleVwiIGlzIGluIHRoZSBmb3JtIG9mIFwiTkFNRVNQQUNFL2tleS5mcm9tLnN0cmluZ3MuanNvblwiXHJcbiAqXHJcbiAqIE5PVEU6IFRoaXMgZmlsZSBsaWtlbHkgYmVsb25ncyBpbiBqb2lzdC9qcy9pMThuLywgYnV0IHNob3VsZCBzdGF5IGhlcmUgdG8gbWFrZSBtYWludGVuYW5jZS1yZWxlYXNlIG1haW50YWluYWJpbGl0eSBlYXNpZXIuXHJcbiAqXHJcbiAqIEBhdXRob3IgSm9uYXRoYW4gT2xzb24gPGpvbmF0aGFuLm9sc29uPlxyXG4gKi9cclxuXHJcbmltcG9ydCBQaGV0aW9PYmplY3QgZnJvbSAnLi4vLi4vdGFuZGVtL2pzL1BoZXRpb09iamVjdC5qcyc7XHJcbmltcG9ydCBUYW5kZW0gZnJvbSAnLi4vLi4vdGFuZGVtL2pzL1RhbmRlbS5qcyc7XHJcbmltcG9ydCBDb3VsZE5vdFlldERlc2VyaWFsaXplRXJyb3IgZnJvbSAnLi4vLi4vdGFuZGVtL2pzL0NvdWxkTm90WWV0RGVzZXJpYWxpemVFcnJvci5qcyc7XHJcbmltcG9ydCBJT1R5cGUgZnJvbSAnLi4vLi4vdGFuZGVtL2pzL3R5cGVzL0lPVHlwZS5qcyc7XHJcbmltcG9ydCBPYmplY3RMaXRlcmFsSU8gZnJvbSAnLi4vLi4vdGFuZGVtL2pzL3R5cGVzL09iamVjdExpdGVyYWxJTy5qcyc7XHJcbmltcG9ydCBMb2NhbGl6ZWRTdHJpbmcsIHsgTG9jYWxpemVkU3RyaW5nU3RhdGVEZWx0YSwgU3RyaW5nc1N0YXRlU3RhdGVPYmplY3QgfSBmcm9tICcuL0xvY2FsaXplZFN0cmluZy5qcyc7XHJcbmltcG9ydCBUUmVhZE9ubHlQcm9wZXJ0eSBmcm9tICcuLi8uLi9heG9uL2pzL1RSZWFkT25seVByb3BlcnR5LmpzJztcclxuaW1wb3J0IHsgTG9jYWxlIH0gZnJvbSAnLi4vLi4vam9pc3QvanMvaTE4bi9sb2NhbGVQcm9wZXJ0eS5qcyc7XHJcbmltcG9ydCBsb2NhbGVJbmZvTW9kdWxlIGZyb20gJy4uLy4uL2NoaXBwZXIvanMvZGF0YS9sb2NhbGVJbmZvTW9kdWxlLmpzJztcclxuaW1wb3J0IHsgUGhldGlvSUQgfSBmcm9tICcuLi8uLi90YW5kZW0vanMvVGFuZGVtQ29uc3RhbnRzLmpzJztcclxuXHJcbi8vIGNvbnN0YW50c1xyXG5jb25zdCBGQUxMQkFDS19MT0NBTEUgPSAnZW4nO1xyXG5cclxuLy8gSG9sZHMgYWxsIG9mIG91ciBsb2NhbGl6ZWRTdHJpbmdzLCBzbyB0aGF0IHdlIGNhbiBzYXZlIG91ciBwaGV0LWlvIHN0cmluZyBjaGFuZ2Ugc3RhdGVcclxuZXhwb3J0IGNvbnN0IGxvY2FsaXplZFN0cmluZ3M6IExvY2FsaXplZFN0cmluZ1tdID0gW107XHJcblxyXG4vLyBGb3IgZGV2ZWxvcGVyIGludGVybmFsIHVzZSwgcGFydGljdWxhcmx5IGZvciBtZW1vcnkgbGVhayBkZXRlY3Rpb25cclxuLy8gZS5nLiBfLm1heCggcGhldC5jaGlwcGVyLmxvY2FsaXplZFN0cmluZ3MubWFwKCBscyA9PiBscy5wcm9wZXJ0eS50aW55UHJvcGVydHkubGlzdGVuZXJzLnNpemUgKSApIHRvIHNlZSBpZiB0aGVyZSBpc1xyXG4vLyBsaWtlbHkgYSBsZWFrXHJcbndpbmRvdy5waGV0LmNoaXBwZXIubG9jYWxpemVkU3RyaW5ncyA9IGxvY2FsaXplZFN0cmluZ3M7XHJcblxyXG4vLyBGb3IgZGV2ZWxvcGVyIGludGVybmFsIHVzZSwgc2ltaWxhciB0byB0aGUgc3RyaW5nVGVzdCBxdWVyeSBwYXJhbWV0ZXJcclxud2luZG93LnBoZXQuY2hpcHBlci5zZXRBbGxTdHJpbmdzID0gKCBzdHI6IHN0cmluZyApID0+IHtcclxuICBsb2NhbGl6ZWRTdHJpbmdzLmZvckVhY2goIGxvY2FsaXplZFN0cmluZyA9PiB7XHJcbiAgICBsb2NhbGl6ZWRTdHJpbmcucHJvcGVydHkudmFsdWUgPSBzdHI7XHJcbiAgfSApO1xyXG59O1xyXG5cclxuY29uc3Qgc3RyaW5nS2V5VG9UYW5kZW1OYW1lID0gKCBrZXk6IHN0cmluZyApID0+IHtcclxuICByZXR1cm4ga2V5LnJlcGxhY2UoIC8oPzpbLV9cXHNdXFx3KS9nLCB3b3JkID0+IHdvcmRbIDEgXS50b1VwcGVyQ2FzZSgpICk7XHJcbn07XHJcblxyXG5jb25zdCBTdHJpbmdTdGF0ZUlPVHlwZSA9IG5ldyBJT1R5cGU8UGhldGlvT2JqZWN0LCBTdHJpbmdzU3RhdGVTdGF0ZU9iamVjdD4oICdTdHJpbmdTdGF0ZUlPJywge1xyXG4gIHZhbHVlVHlwZTogUGhldGlvT2JqZWN0LFxyXG4gIHRvU3RhdGVPYmplY3Q6ICgpOiBTdHJpbmdzU3RhdGVTdGF0ZU9iamVjdCA9PiB7XHJcbiAgICBjb25zdCBkYXRhOiBSZWNvcmQ8UGhldGlvSUQsIExvY2FsaXplZFN0cmluZ1N0YXRlRGVsdGE+ID0ge307XHJcblxyXG4gICAgbG9jYWxpemVkU3RyaW5ncy5mb3JFYWNoKCBsb2NhbGl6ZWRTdHJpbmcgPT4ge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IGxvY2FsaXplZFN0cmluZy5nZXRTdGF0ZURlbHRhKCk7XHJcblxyXG4gICAgICAvLyBPbmx5IGNyZWF0ZSBhbiBlbnRyeSBpZiB0aGVyZSBpcyBhbnl0aGluZyAod2UgY2FuIHNhdmUgYnl0ZXMgYnkgbm90IGluY2x1ZGluZyB0aGUgdGFuZGVtIGhlcmUpXHJcbiAgICAgIGlmICggT2JqZWN0LmtleXMoIHN0YXRlICkubGVuZ3RoID4gMCApIHtcclxuICAgICAgICBkYXRhWyBsb2NhbGl6ZWRTdHJpbmcucHJvcGVydHkudGFuZGVtLnBoZXRpb0lEIF0gPSBzdGF0ZTtcclxuICAgICAgfVxyXG4gICAgfSApO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZGF0YTogZGF0YSAvLyBEYXRhIG5lc3RlZCBmb3IgYSB2YWxpZCBzY2hlbWFcclxuICAgIH07XHJcbiAgfSxcclxuICBzdGF0ZVNjaGVtYToge1xyXG4gICAgZGF0YTogT2JqZWN0TGl0ZXJhbElPXHJcbiAgfSxcclxuICBhcHBseVN0YXRlOiAoIGlnbm9yZWQsIHN0YXRlICkgPT4ge1xyXG5cclxuICAgIC8vIEV2ZXJ5IHN0cmluZyBpbiBzdGF0ZSBoYXMgdG8gYmUgaW4gbG9jYWxpemVkU3RyaW5ncyB0byBjb250aW51ZVxyXG4gICAgT2JqZWN0LmtleXMoIHN0YXRlLmRhdGEgKS5mb3JFYWNoKCBwaGV0aW9JRCA9PiB7XHJcbiAgICAgIGNvbnN0IG1hdGNoID0gbG9jYWxpemVkU3RyaW5ncy5maW5kKCBsb2NhbGl6ZWRTdHJpbmcgPT4gbG9jYWxpemVkU3RyaW5nLnByb3BlcnR5LnRhbmRlbS5waGV0aW9JRCA9PT0gcGhldGlvSUQgKTtcclxuXHJcbiAgICAgIC8vIFdoZW4gUGhldGlvRHluYW1pY0VsZW1lbnRDb250YWluZXIgZWxlbWVudHMgc3VjaCBhcyBQaGV0aW9Hcm91cCBtZW1iZXJzIGFkZCBsb2NhbGl6ZWRTdHJpbmdzLCB3ZSB3YWl0IHVudGlsXHJcbiAgICAgIC8vIGFsbCBvZiB0aGUgbWVtYmVycyBoYXZlIGJlZW4gY3JlYXRlZCAocG9wdWxhdGluZyBsb2NhbGl6ZWRTdHJpbmdzKSBiZWZvcmUgdHJ5aW5nIHRvIHNldCBhbnkgb2YgdGhlIHN0cmluZ3MuXHJcbiAgICAgIGlmICggIW1hdGNoICkge1xyXG4gICAgICAgIHRocm93IG5ldyBDb3VsZE5vdFlldERlc2VyaWFsaXplRXJyb3IoKTtcclxuICAgICAgfVxyXG4gICAgfSApO1xyXG5cclxuICAgIC8vIFdlIG5lZWQgdG8gaXRlcmF0ZSB0aHJvdWdoIGV2ZXJ5IHN0cmluZyBpbiB0aGlzIHJ1bnRpbWUsIHNpbmNlIGl0IG1pZ2h0IG5lZWQgdG8gcmV2ZXJ0IGJhY2sgdG8gXCJpbml0aWFsXCIgc3RhdGUuXHJcbiAgICBsb2NhbGl6ZWRTdHJpbmdzLmZvckVhY2goIGxvY2FsaXplZFN0cmluZyA9PiB7XHJcbiAgICAgIGxvY2FsaXplZFN0cmluZy5zZXRTdGF0ZURlbHRhKCBzdGF0ZS5kYXRhWyBsb2NhbGl6ZWRTdHJpbmcucHJvcGVydHkudGFuZGVtLnBoZXRpb0lEIF0gfHwge30gKTtcclxuICAgIH0gKTtcclxuICB9XHJcbn0gKTtcclxuXHJcblBoZXRpb09iamVjdC5jcmVhdGUoIHtcclxuICBwaGV0aW9UeXBlOiBTdHJpbmdTdGF0ZUlPVHlwZSxcclxuICB0YW5kZW06IFRhbmRlbS5HRU5FUkFMX01PREVMLmNyZWF0ZVRhbmRlbSggJ3N0cmluZ3NTdGF0ZScgKSxcclxuICBwaGV0aW9Eb2N1bWVudGF0aW9uOiAnU3RyaW5ncyB0aGF0IGhhdmUgY2hhbmdlZCBmcm9tIHRoZWlyIGluaXRpYWwgdmFsdWVzLiBFYWNoIHN0cmluZyB2YWx1ZSBpcyBzcGVjaWZpYyB0byB0aGUgbG9jYWxlIGl0IGNoYW5nZWQgaW4uJyxcclxuICBwaGV0aW9TdGF0ZTogdHJ1ZVxyXG59ICk7XHJcblxyXG50eXBlIFRTdHJpbmdNb2R1bGUgPSB7XHJcbiAgWyBrZXk6IHN0cmluZyBdOiBUU3RyaW5nTW9kdWxlIHwgc3RyaW5nIHwgVFJlYWRPbmx5UHJvcGVydHk8c3RyaW5nPjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0gcmVxdWlyZWpzTmFtZXNwYWNlIC0gRS5nLiAnSk9JU1QnLCB0byBwdWxsIHN0cmluZyBrZXlzIG91dCBmcm9tIHRoYXQgbmFtZXNwYWNlXHJcbiAqIEByZXR1cm5zIE5lc3RlZCBvYmplY3QgdG8gYmUgYWNjZXNzZWQgbGlrZSBKb2lzdFN0cmluZ3MuUmVzZXRBbGxCdXR0b24ubmFtZVxyXG4gKi9cclxuY29uc3QgZ2V0U3RyaW5nTW9kdWxlID0gKCByZXF1aXJlanNOYW1lc3BhY2U6IHN0cmluZyApOiBvYmplY3QgPT4ge1xyXG4gIC8vIE91ciBzdHJpbmcgaW5mb3JtYXRpb24gaXMgcHVsbGVkIGdsb2JhbGx5LCBlLmcuIHBoZXQuY2hpcHBlci5zdHJpbmdzWyBsb2NhbGUgXVsgc3RyaW5nS2V5IF0gPSBzdHJpbmdWYWx1ZTtcclxuICAvLyBPdXIgbG9jYWxlIGluZm9ybWF0aW9uIGlzIGZyb20gcGhldC5jaGlwcGVyLmxvY2FsZVxyXG5cclxuICBhc3NlcnQgJiYgYXNzZXJ0KCB0eXBlb2YgcGhldC5jaGlwcGVyLmxvY2FsZSA9PT0gJ3N0cmluZycsICdwaGV0LmNoaXBwZXIubG9jYWxlIHNob3VsZCBoYXZlIGJlZW4gbG9hZGVkIGJ5IG5vdycgKTtcclxuICBhc3NlcnQgJiYgYXNzZXJ0KCBPYmplY3Qua2V5cyggbG9jYWxlSW5mb01vZHVsZSApLmluY2x1ZGVzKCBwaGV0LmNoaXBwZXIubG9jYWxlICksICdwaGV0LmNoaXBwZXIubG9jYWxlIHNob3VsZCBoYXZlIGJlZW4gbG9hZGVkIGJ5IG5vdycgKTtcclxuICBhc3NlcnQgJiYgYXNzZXJ0KCBwaGV0LmNoaXBwZXIuc3RyaW5ncywgJ3BoZXQuY2hpcHBlci5zdHJpbmdzIHNob3VsZCBoYXZlIGJlZW4gbG9hZGVkIGJ5IG5vdycgKTtcclxuXHJcbiAgLy8gQ29uc3RydWN0IGxvY2FsZXMgaW4gaW5jcmVhc2luZyBzcGVjaWZpY2l0eSwgZS5nLiBbICdlbicsICd6aCcsICd6aF9DTicgXSwgc28gd2UgZ2V0IGZhbGxiYWNrcyBpbiBvcmRlclxyXG4gIC8vIGNvbnN0IGxvY2FsZXMgPSBbIEZBTExCQUNLX0xPQ0FMRSBdO1xyXG4gIGNvbnN0IHN0cmluZ0tleVByZWZpeCA9IGAke3JlcXVpcmVqc05hbWVzcGFjZX0vYDtcclxuXHJcbiAgLy8gV2UgbWF5IGhhdmUgb3RoZXIgb2xkZXIgKHVudXNlZCkga2V5cyBpbiBiYWJlbCwgYW5kIHdlIGFyZSBvbmx5IGRvaW5nIHRoZSBzZWFyY2ggdGhhdCBtYXR0ZXJzIHdpdGggdGhlIEVuZ2xpc2hcclxuICAvLyBzdHJpbmcga2V5cy5cclxuICBsZXQgYWxsU3RyaW5nS2V5c0luUmVwbyA9IE9iamVjdC5rZXlzKCBwaGV0LmNoaXBwZXIuc3RyaW5nc1sgRkFMTEJBQ0tfTE9DQUxFIF0gKS5maWx0ZXIoIHN0cmluZ0tleSA9PiBzdHJpbmdLZXkuc3RhcnRzV2l0aCggc3RyaW5nS2V5UHJlZml4ICkgKTtcclxuXHJcbiAgLy8gVE9ETzogaHR0cHM6Ly9naXRodWIuY29tL3BoZXRzaW1zL3BoZXQtaW8vaXNzdWVzLzE4NzcgV2hhdCBpZiB0aGlzIGxpc3QgZG9lc24ndCBleGlzdD8gIFNob3VsZCB0aGF0IGJlIGFuIGVycm9yP1xyXG4gIC8vIE9yIGFuIGVycm9yIGlmIHJ1bm5pbmcgYW4gYXBpLXN0YWJsZSBwaGV0LWlvIHNpbT9cclxuICAvLyBUT0RPOiBodHRwczovL2dpdGh1Yi5jb20vcGhldHNpbXMvcGhldC1pby9pc3N1ZXMvMTg3NyBXaGF0IHdpbGwgaGFwcGVuIGlmIHRoaXMgaXMgc3RhbGU/IEhvdyB3aWxsIGEgZGV2ZWxvcGVyIGtub3dcclxuICAvLyB0byB1cGRhdGUgaXQ/IFNob3VsZCBpdCBydW4gaW4gZGFpbHktZ3J1bnQtd29yaz9cclxuICBpZiAoIHBoZXQuY2hpcHBlci51c2VkU3RyaW5nc0VOICkge1xyXG4gICAgYWxsU3RyaW5nS2V5c0luUmVwbyA9IGFsbFN0cmluZ0tleXNJblJlcG8uZmlsdGVyKCBzdHJpbmdLZXkgPT4gcGhldC5jaGlwcGVyLnVzZWRTdHJpbmdzRU4uaGFzT3duUHJvcGVydHkoIHN0cmluZ0tleSApICk7XHJcbiAgfVxyXG5cclxuICAvLyBsb2NhbGl6ZWRTdHJpbmdNYXBbIHN0cmluZ0tleSBdXHJcbiAgY29uc3QgbG9jYWxpemVkU3RyaW5nTWFwOiBSZWNvcmQ8c3RyaW5nLCBMb2NhbGl6ZWRTdHJpbmc+ID0ge307XHJcblxyXG4gIGNvbnN0IHN0cmluZ01vZHVsZTogVFN0cmluZ01vZHVsZSA9IHt9O1xyXG5cclxuICBhbGxTdHJpbmdLZXlzSW5SZXBvLmZvckVhY2goIHN0cmluZ0tleSA9PiB7XHJcbiAgICAvLyBzdHJpcCBvZmYgdGhlIHJlcXVpcmVqc05hbWVzcGFjZSwgZS5nLiAnSk9JU1QvUmVzZXRBbGxCdXR0b24ubmFtZScgPT4gJ1Jlc2V0QWxsQnV0dG9uLm5hbWUnXHJcbiAgICBjb25zdCBzdHJpbmdLZXlXaXRob3V0UHJlZml4ID0gc3RyaW5nS2V5LnNsaWNlKCBzdHJpbmdLZXlQcmVmaXgubGVuZ3RoICk7XHJcblxyXG4gICAgY29uc3Qga2V5UGFydHMgPSBzdHJpbmdLZXlXaXRob3V0UHJlZml4LnNwbGl0KCAnLicgKTtcclxuICAgIGNvbnN0IGxhc3RLZXlQYXJ0ID0ga2V5UGFydHNbIGtleVBhcnRzLmxlbmd0aCAtIDEgXTtcclxuICAgIGNvbnN0IGFsbEJ1dExhc3RLZXlQYXJ0ID0ga2V5UGFydHMuc2xpY2UoIDAsIGtleVBhcnRzLmxlbmd0aCAtIDEgKTtcclxuXHJcbiAgICAvLyBEdXJpbmcgdHJhdmVyc2FsIGludG8gdGhlIHN0cmluZyBvYmplY3QsIHRoaXMgd2lsbCBob2xkIHRoZSBvYmplY3Qgd2hlcmUgdGhlIG5leHQgbGV2ZWwgbmVlZHMgdG8gYmUgZGVmaW5lZCxcclxuICAgIC8vIHdoZXRoZXIgdGhhdCdzIGFub3RoZXIgY2hpbGQgb2JqZWN0LCBvciB0aGUgc3RyaW5nIHZhbHVlIGl0c2VsZi5cclxuICAgIGxldCByZWZlcmVuY2U6IFRTdHJpbmdNb2R1bGUgPSBzdHJpbmdNb2R1bGU7XHJcblxyXG4gICAgLy8gV2UnbGwgdHJhdmVyc2UgZG93biB0aHJvdWdoIHRoZSBwYXJ0cyBvZiBhIHN0cmluZyBrZXkgKHNlcGFyYXRlZCBieSAnLicpLCBjcmVhdGluZyBhIG5ldyBsZXZlbCBpbiB0aGVcclxuICAgIC8vIHN0cmluZyBvYmplY3QgZm9yIGVhY2ggb25lLiBUaGlzIGlzIGRvbmUgZm9yIGFsbCBCVVQgdGhlIGxhc3QgcGFydCwgc2luY2Ugd2UnbGwgd2FudCB0byBhc3NpZ24gdGhlIHJlc3VsdFxyXG4gICAgLy8gb2YgdGhhdCB0byBhIHJhdyBzdHJpbmcgdmFsdWUgKHJhdGhlciB0aGFuIGFuIG9iamVjdCkuXHJcbiAgICBsZXQgcGFydGlhbEtleSA9IHN0cmluZ0tleVByZWZpeDtcclxuICAgIGFsbEJ1dExhc3RLZXlQYXJ0LmZvckVhY2goICgga2V5UGFydCwgaSApID0+IHtcclxuICAgICAgLy8gV2hlbiBjb25jYXRlbmF0aW5nIGVhY2ggbGV2ZWwgaW50byB0aGUgZmluYWwgc3RyaW5nIGtleSwgd2UgZG9uJ3Qgd2FudCB0byBwdXQgYSAnLicgZGlyZWN0bHkgYWZ0ZXIgdGhlXHJcbiAgICAgIC8vIHNsYXNoLCBiZWNhdXNlIGBKT0lTVC8uUmVzZXRBbGxCdXR0b24ubmFtZWAgd291bGQgYmUgaW52YWxpZC5cclxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9jaGlwcGVyL2lzc3Vlcy85MjJcclxuICAgICAgcGFydGlhbEtleSArPSBgJHtpID4gMCA/ICcuJyA6ICcnfSR7a2V5UGFydH1gO1xyXG5cclxuICAgICAgLy8gRG9uJ3QgYWxsb3cgZS5nLiBKT0lTVC9hIGFuZCBKT0lTVC9hLmIsIHNpbmNlIGxvY2FsZU9iamVjdC5hIHdvdWxkIG5lZWQgdG8gYmUgYSBzdHJpbmcgQU5EIGFuIG9iamVjdCBhdCB0aGVcclxuICAgICAgLy8gc2FtZSB0aW1lLlxyXG4gICAgICBhc3NlcnQgJiYgYXNzZXJ0KCB0eXBlb2YgcmVmZXJlbmNlWyBrZXlQYXJ0IF0gIT09ICdzdHJpbmcnLFxyXG4gICAgICAgICdJdCBpcyBub3QgYWxsb3dlZCB0byBoYXZlIHR3byBkaWZmZXJlbnQgc3RyaW5nIGtleXMgd2hlcmUgb25lIGlzIGV4dGVuZGVkIGJ5IGFkZGluZyBhIHBlcmlvZCAoLikgYXQgdGhlIGVuZCAnICtcclxuICAgICAgICBgb2YgdGhlIG90aGVyLiBUaGUgc3RyaW5nIGtleSAke3BhcnRpYWxLZXl9IGlzIGV4dGVuZGVkIGJ5ICR7c3RyaW5nS2V5fSBpbiB0aGlzIGNhc2UsIGFuZCBzaG91bGQgYmUgY2hhbmdlZC5gICk7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgdGhlIG5leHQgbmVzdGVkIGxldmVsLCBhbmQgbW92ZSBpbnRvIGl0XHJcbiAgICAgIGlmICggIXJlZmVyZW5jZVsga2V5UGFydCBdICkge1xyXG4gICAgICAgIHJlZmVyZW5jZVsga2V5UGFydCBdID0ge307XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlZmVyZW5jZSA9IHJlZmVyZW5jZVsga2V5UGFydCBdIGFzIFRTdHJpbmdNb2R1bGU7IC8vIHNpbmNlIHdlIGFyZSBvbiBhbGwgYnV0IHRoZSBsYXN0IGtleSBwYXJ0LCBpdCBjYW5ub3QgYmUgc3RyaW5nbGlrZVxyXG4gICAgfSApO1xyXG5cclxuICAgIGFzc2VydCAmJiBhc3NlcnQoIHR5cGVvZiByZWZlcmVuY2VbIGxhc3RLZXlQYXJ0IF0gIT09ICdvYmplY3QnLFxyXG4gICAgICAnSXQgaXMgbm90IGFsbG93ZWQgdG8gaGF2ZSB0d28gZGlmZmVyZW50IHN0cmluZyBrZXlzIHdoZXJlIG9uZSBpcyBleHRlbmRlZCBieSBhZGRpbmcgYSBwZXJpb2QgKC4pIGF0IHRoZSBlbmQgJyArXHJcbiAgICAgIGBvZiB0aGUgb3RoZXIuIFRoZSBzdHJpbmcga2V5ICR7c3RyaW5nS2V5fSBpcyBleHRlbmRlZCBieSBhbm90aGVyIGtleSwgc29tZXRoaW5nIGNvbnRhaW5pbmcgJHtyZWZlcmVuY2VbIGxhc3RLZXlQYXJ0IF0gJiYgT2JqZWN0LmtleXMoIHJlZmVyZW5jZVsgbGFzdEtleVBhcnQgXSApfS5gICk7XHJcbiAgICBhc3NlcnQgJiYgYXNzZXJ0KCAhcmVmZXJlbmNlWyBsYXN0S2V5UGFydCBdLFxyXG4gICAgICBgV2Ugc2hvdWxkIG5vdCBoYXZlIGRlZmluZWQgdGhpcyBwbGFjZSBpbiB0aGUgb2JqZWN0ICgke3N0cmluZ0tleX0pLCBvdGhlcndpc2UgaXQgbWVhbnMgYSBkdXBsaWNhdGVkIHN0cmluZyBrZXkgT1IgZXh0ZW5kZWQgc3RyaW5nIGtleWAgKTtcclxuXHJcbiAgICAvLyBJbiBjYXNlIG91ciBhc3NlcnRpb25zIGFyZSBub3QgZW5hYmxlZCwgd2UnbGwgbmVlZCB0byBwcm9jZWVkIHdpdGhvdXQgZmFpbGluZyBvdXQgKHNvIHdlIGFsbG93IGZvciB0aGVcclxuICAgIC8vIGV4dGVuZGVkIHN0cmluZyBrZXlzIGluIG91ciBhY3R1YWwgY29kZSwgZXZlbiB0aG91Z2ggYXNzZXJ0aW9ucyBzaG91bGQgcHJldmVudCB0aGF0KS5cclxuICAgIGlmICggdHlwZW9mIHJlZmVyZW5jZSAhPT0gJ3N0cmluZycgKSB7XHJcbiAgICAgIGxldCB0YW5kZW0gPSBUYW5kZW0uU1RSSU5HUy5jcmVhdGVUYW5kZW0oIF8uY2FtZWxDYXNlKCByZXF1aXJlanNOYW1lc3BhY2UgKSApO1xyXG4gICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBrZXlQYXJ0cy5sZW5ndGg7IGkrKyApIHtcclxuXHJcbiAgICAgICAgbGV0IHRhbmRlbU5hbWUgPSBzdHJpbmdLZXlUb1RhbmRlbU5hbWUoIGtleVBhcnRzWyBpIF0gKTtcclxuXHJcbiAgICAgICAgLy8gSWYgaXQgaXMgdGhlIHRhaWwgb2YgdGhlIHN0cmluZyBrZXksIHRoZW4gbWFrZSB0aGUgdGFuZGVtIGJlIGEgXCIqU3RyaW5nUHJvcGVydHlcIlxyXG4gICAgICAgIGlmICggaSA9PT0ga2V5UGFydHMubGVuZ3RoIC0gMSApIHtcclxuXHJcbiAgICAgICAgICBsZXQgY3VycmVudFRhbmRlbU5hbWUgPSB0YW5kZW1OYW1lO1xyXG4gICAgICAgICAgbGV0IGogPSAwO1xyXG4gICAgICAgICAgbGV0IHRhbmRlbU5hbWVUYWtlbiA9IHRydWU7XHJcblxyXG4gICAgICAgICAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIHR3byB1bmlxdWUgc3RyaW5nIGtleXMgbWFwIHRvIHRoZSBzYW1lIGNhbWVsIGNhc2UgdmFsdWUsIGkuZS4gXCJTb2xpZFwiIGFuZCBcInNvbGlkXCIuXHJcbiAgICAgICAgICAvLyBIZXJlIHdlIHdpbGwgYmUgc29saWRTdHJpbmdQcm9wZXJ0eSBhbmQgc29saWQyU3RyaW5nUHJvcGVydHlcclxuICAgICAgICAgIHdoaWxlICggdGFuZGVtTmFtZVRha2VuICkge1xyXG4gICAgICAgICAgICBqKys7XHJcblxyXG4gICAgICAgICAgICBjdXJyZW50VGFuZGVtTmFtZSA9IGAke3RhbmRlbU5hbWV9JHtqID09PSAxID8gJycgOiBqfVN0cmluZ1Byb3BlcnR5YDtcclxuXHJcbiAgICAgICAgICAgIHRhbmRlbU5hbWVUYWtlbiA9IHRhbmRlbS5oYXNDaGlsZCggY3VycmVudFRhbmRlbU5hbWUgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRhbmRlbU5hbWUgPSBjdXJyZW50VGFuZGVtTmFtZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRhbmRlbSA9IHRhbmRlbS5jcmVhdGVUYW5kZW0oIHRhbmRlbU5hbWUgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gc3RyaW5ncyBuZXN0ZWQgdW5kZXIgdGhlIGExMXkgc2VjdGlvbiBhcmUgbm90IGN1cnJlbnRseSBQaEVULWlPIGluc3RydW1lbnRlZCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9jaGlwcGVyL2lzc3Vlcy8xMzUyXHJcbiAgICAgIGlmICggdGFuZGVtLnBoZXRpb0lELmluY2x1ZGVzKCAnLmExMXkuJyApICkge1xyXG4gICAgICAgIHRhbmRlbSA9IFRhbmRlbS5PUFRfT1VUO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBsb2NhbGl6ZWRTdHJpbmcgPSBuZXcgTG9jYWxpemVkU3RyaW5nKFxyXG4gICAgICAgIHN0cmluZ0tleSxcclxuICAgICAgICBwaGV0LmNoaXBwZXIubWFwU3RyaW5nKCBwaGV0LmNoaXBwZXIuc3RyaW5nc1sgRkFMTEJBQ0tfTE9DQUxFIF1bIHN0cmluZ0tleSBdICksXHJcbiAgICAgICAgdGFuZGVtLFxyXG4gICAgICAgIHBoZXQuY2hpcHBlci5zdHJpbmdNZXRhZGF0YVsgc3RyaW5nS2V5IF1cclxuICAgICAgKTtcclxuICAgICAgbG9jYWxpemVkU3RyaW5nTWFwWyBzdHJpbmdLZXkgXSA9IGxvY2FsaXplZFN0cmluZztcclxuXHJcbiAgICAgIC8vIFB1c2ggdXAgdGhlIHRyYW5zbGF0ZWQgdmFsdWVzXHJcbiAgICAgICggT2JqZWN0LmtleXMoIHBoZXQuY2hpcHBlci5zdHJpbmdzICkgYXMgTG9jYWxlW10gKS5mb3JFYWNoKCAoIGxvY2FsZTogTG9jYWxlICkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN0cmluZzogc3RyaW5nID0gcGhldC5jaGlwcGVyLnN0cmluZ3NbIGxvY2FsZSBdWyBzdHJpbmdLZXkgXTtcclxuICAgICAgICAvLyBJZ25vcmUgemVyby1sZW5ndGggc3RyaW5ncywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waGV0c2ltcy9jaGlwcGVyL2lzc3Vlcy8xMzQzXHJcbiAgICAgICAgaWYgKCB0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJyAmJiBzdHJpbmcgIT09ICcnICkge1xyXG4gICAgICAgICAgbG9jYWxpemVkU3RyaW5nLnNldEluaXRpYWxWYWx1ZSggbG9jYWxlLCBwaGV0LmNoaXBwZXIubWFwU3RyaW5nKCBzdHJpbmcgKSApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSApO1xyXG5cclxuICAgICAgLy8gUHV0IG91ciBQcm9wZXJ0eSBpbiB0aGUgc3RyaW5nTW9kdWxlXHJcbiAgICAgIHJlZmVyZW5jZVsgYCR7bGFzdEtleVBhcnR9U3RyaW5nUHJvcGVydHlgIF0gPSBsb2NhbGl6ZWRTdHJpbmcucHJvcGVydHk7XHJcblxyXG4gICAgICAvLyBDaGFuZ2Ugb3VyIHN0cmluZ01vZHVsZSBiYXNlZCBvbiB0aGUgUHJvcGVydHkgdmFsdWVcclxuICAgICAgbG9jYWxpemVkU3RyaW5nLnByb3BlcnR5LmxpbmsoIHN0cmluZyA9PiB7XHJcbiAgICAgICAgcmVmZXJlbmNlWyBsYXN0S2V5UGFydCBdID0gc3RyaW5nO1xyXG4gICAgICB9ICk7XHJcbiAgICB9XHJcbiAgfSApO1xyXG5cclxuICByZXR1cm4gc3RyaW5nTW9kdWxlO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZ2V0U3RyaW5nTW9kdWxlOyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLFlBQVksTUFBTSxpQ0FBaUM7QUFDMUQsT0FBT0MsTUFBTSxNQUFNLDJCQUEyQjtBQUM5QyxPQUFPQywyQkFBMkIsTUFBTSxnREFBZ0Q7QUFDeEYsT0FBT0MsTUFBTSxNQUFNLGlDQUFpQztBQUNwRCxPQUFPQyxlQUFlLE1BQU0sMENBQTBDO0FBQ3RFLE9BQU9DLGVBQWUsTUFBOEQsc0JBQXNCO0FBRzFHLE9BQU9DLGdCQUFnQixNQUFNLDJDQUEyQztBQUd4RTtBQUNBLE1BQU1DLGVBQWUsR0FBRyxJ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